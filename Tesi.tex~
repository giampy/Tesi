\documentclass[a4paper,openright,twoside,12pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs 
\usepackage{float}
\author{Gian Pietro Farina}
\hyphenation{li-mi-ta-te li-mi-ta-ti e-qui-va-len-ti ov-via-men-te pse-u-do-ca-sua-le sem-bre-reb-be}
\floatstyle{boxed} 
\restylefloat{figure}
\newtheorem{definizione}{Definizione}[chapter]
\newtheorem{proposizione}{Proposizione}[chapter]
\newtheorem{teorema}{Teorema}[chapter]
\pagenumbering{arabic}
\pagestyle{fancy}
% i comandi seguenti impediscono la scrittura in maiuscolo
% dei nomi dei capitoli e dei paragrafi nelle intestazioni
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
            % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
   \fancyhead{} % ignora, nello stile plain, le intestazioni
   \renewcommand{\headrulewidth}{0pt} % e la linea
}

\newcommand{\foreach}[2]{\textbf{foreach #1} $\leq$ \textbf{#2} \textbf{do}}
\newcommand{\return}[1]{\textbf{return}(#1);}
\renewcommand{\do}{\textbf{do}}
\newcommand{\pipe}{ \textbf{|} \\ \\}
\newcommand{\setR}[2]{#1 $\xleftarrow{R}$ #2;}
\newcommand{\set}[2]{#1 $\leftarrow$ #2;}
\newcommand{\ifthen}[2]{\textbf{if} #1 \textbf{then} #2}
\newcommand{\find}[6]{\textbf{find #1} $\leq$ \textbf{#2 suchthat} (\textbf{defined}(#3) $\wedge$ #4)) \textbf{then} #5 \\ \textbf{else} #6}
\newcommand{\event}{\textbf{event}}
\newcommand{\myend}{\textbf{end}}
\newcommand{\equiva}{\textbf{equiv}}
\begin{document}
\chapter*{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}
Negli anni anni '80 la crittografia ha cessato di essere un' arte per assurgere allo stato di scienza. \\Come scienza, la crittografia moderna
si propone innanzi tutto di fornire definizioni rigorose dei concetti con cui ha a che fare (e.g. \emph{segretezza}) per poi apportare prove dei propri asserti basandosi 
su argomentazioni di carattere logico-matematico, ovvero di dimostrazioni. \\
Sebbene in alcuni casi sia possibile (ed \`e stato fatto, i.e ~\cite{Shannon}) \emph{incondizionatamente} provare dei risultati, la maggior parte delle prove di teoremi, nel campo 
della crittografia moderna, sono basate su assunzioni che non sono ancora certe, ma che sono comunque ben formalizzate e inequivocabilmente descritte.\\La pi\`u importante \`e sicuramente
l'ipotesi dell'esistenza di funzioni \emph{one-way}. Tutte le prove che sono basate su assunzioni non verificate sono sempre e comunque valide, sia che le assunzioni fatte vengano dimostrate,
sia che vengano confutate; questo perch\'e ogni dimostrazione \`e del tipo: \emph{Se X allora Y} (e.g. se esiste una funzione one-way allora esiste un generatore pseudocasuale con fattore
d'espansione polinomiale). Semplicemente, nel caso in cui le assunzioni dovessero essere confutate si renderebbero poco interessanti le dimostrazioni che si basano su queste\footnote{\`E ovvio che partendo da ipotesi false si possa
dimostrare qualsiasi cosa.}.
\`E per\`o giusto dire che le assunzioni che vengono fatte sono largamente ritenute vere; questo anche  grazie al fatto che alcune di esse si possono dedurre da altre ipotesi 
anche queste ampiamente accettate sebbene non dimostrate.\\Lo studio di una congettura, infatti, pu\`o fornire evidenti prove della sua validit\`a mostrando che essa \`e la tesi di un teorema che assume come ipotesi
un'altra congettura largamente ritenuta valida.
Da quando la crittografia si \`e guadagnata una validit\`a scientifica, sono nati almeno due modi profondamente diversi fra loro di
studiarla.\\In uno di questi, il modello \emph{formale}, le operazioni crittografiche sono rappresentate da espressioni simboliche, formali.
Nell'altro, il modello \emph{computazionale}, le operazioni crittografiche sono viste come funzioni su stringhe di bit che hanno una semantica probabilistica.
Il primo modello \`e stato ampiamente trattato in \cite{AbadiG99, BurrowsAN90, Kemmerer87, Paulson98}. 
Il secondo modello trova le basi in lavori di altrettanto illustri studiosi \cite{}.\\
Il modello formale pu\`o contare su un vastissimo insieme di conoscenze teoriche derivanti da altri rami dell'informatica, in particolare la teoria dei linguaggi formali e della logica;
anche per questo il modello formale \`e stato sicuramente trattato in modo pi\`u approfondito, almeno fino ad ora. Questo ha fatto s\`i che lo stato dell'arte veda, per esempio, molti pi\`u tool di
verifica automatica che lavorano nel modello formale rispetto a tool che lavorano nel modello computazionale. 
Uno tra i pi\`u famosi tool che lavora nel modello formale \`e sicuramente il \emph{ProVerif}\footnote{Per informazioni pi\`u dettagliate su questo tool si visiti il seguente sito web: 
\url{http://www.proverif.ens.fr/}}.
I sostenitori del modello formale affermano che \`e molto conveniente ignorare i dettagli di una funzione crittografica e lavorare con una descrizione 
di pi\`u alto livello di questa e che non includa dettagli riguardanti la funzione crittografica. I sostenitori del modello crittografico computazionale, invece, affermano che la visione
del modello formale non \`e molto realistica e che le funzioni crittografiche non devono essere viste come espressioni formali, ma come algoritmi deterministici o probabilistici. Inoltre i
sostenitori del modello formale, trattando le primitive crittografiche come dei simboli impenetrabili, assumono implicitamente che siano corrette e inviolabili ma questa non \`e
del tutto esatto. D'altra parte, il modello formale ha molti vantaggi come quello precedentemente accennato che riguarda la semplicit\`a con cui vengono costruiti strumenti automatici per la verifica di protocolli in questo modello.
Sembrerebbe quindi, che esista un divario molto ampio fra i due modelli. In effetti cos\`i \`e, ma non sono mancati i tentativi di unificare le due teorie, o comunque di cercare una linea
di collegamento che li congiunga.
In \cite{DBLP:journals/joc/AbadiR07} gli autori cercano per la prima volta di porre le basi per iniziare a collegare questi due modelli.
In particolare il principale risultato di questo lavoro afferma che se due espressioni nel modello formale sono equivalenti, una volta dotate di un'opportuna semantica probabilistica,
vengono mappati in \emph{ensemble} computazionalmente indistinguibili; quindi, sotto forti ma accettabili ipotesi\footnote{Un'importante ipotesi usata nella dimostrazione del risultato in questione
\`e che non devono esserci cicli crittografici, ovvero si considerano solo schemi crittografici in cui una chiave $k$, non \`e mai \emph{cifrata} attraverso $k$ stessa.}, 
l'equivalenza formale implica l'indistinguibilit\`a computazionale.
\`E quindi lecito affermare che un attaccante per il modello computazionale non \`e pi\`u potente di un attaccante nel modello formale. Questo risultato ha dato un'ulteriore spinta
ai sostenitori del modello formale che potevano cos\`i dimostrare risultati, con tutti i benefici che il modello formale comportava, 
e estendere questo risultato al modello computazionale senza troppi problemi.
Un' altra strada, invece, \`e quella che prevede di lavorare direttamente nel modello computazionale senza preoccuparsi di rispettare le forti ipotesi che erano 
state usate per dimostrare il risultato raggiunto in \cite{DBLP:journals/joc/AbadiR07}.
Rispetto al passato, oggi giorno, la crittografia non \`e utilizzata solo in ambiente militare. I suoi campi di utilizzo si estendono a molti aspetti della vita quotidiana.
Questo fatto ha comportato anche un'estensione dei possibili utilizzi della crittografia. Se infatti, un tempo l'unico scopo che si proponeva la crittografia era quello di garantire
la segretezza oggi giorno deve poter fornire molte altre garanzie fra le quali: autenticazione e integrit\`a dei messaggi scambiati fra due parti. Ecco, quindi, che la nascita di queste esigenze
ha portato allo studio di schemi crittografici come per esempio \emph{message authentication code} oppure schemi crittografici asimmetrici.
Quando si parla di segretezza, \`e importante, come gi\`a accennato, dare prima una definizione di cosa si intenda con questo termine.
Se per esempio si intende che nessun attaccante possa mai venire a conoscenza della chiave allora si ottiene qualcosa che non \`e quello che si vorrebbe. La segretezza, infatti, riguarda un messaggio, 
la chiave \`e solo un mezzo che si utilizza per ottenere questo fine. 
Se invece si intende che un attaccante non riesca mai a decifrare il messaggio si \`e alla ricerca di una chimera, perch\'e come si vedr\`a nel proseguo, posto che si abbia sufficiente tempo 
a disposizione si pu\`o sempre riuscire a decifrare con \emph{certezza} il messaggio; inoltre esiste sempre la possiblit\`a che un attaccante riesca ad indovinare il messaggio
semplicemente \emph{tirando ad indovinare}. Se infine, si intende che ogni attaccante con determinate caratteristiche riesca difficilmente ad indovinare il messaggio cifrato, allora esiste la 
possibilit\`a di ottenere schemi che rispettano questo tipo di definizione.
Una tenica molto utilizzata per provare dei risultati nell'ambito della crittografia computazionale \`e la cosidetta ``tecnica per riduzione''. 
Le dimostrazioni di sicurezza basate su questa tecnica consistono nel mostrare che se esiste un aversario che pu\`o vincere con una probabilit\`a significativa e in un
tempo ragionevole allora anche un problema ben definito pu\`o essere risolto con una probabilit\`a significativa e in un tempo ragionevole. Ovviamente si cerca di ridurre
lo schema crittografico ad un problema che si sa bene essere difficile da risolvere.

\chapter{Il Modello Computazionale}
In questo capitolo si cercher\`a di descrivere le principali caratteristiche del modello computazionale. Saranno resi evidenti alcuni legami che
esistono fra la crittografia, la teoria della calcolabilit\`a e alcune nozioni di statistica e probababilit\`a. Sono questi infatti i cardini su cui poggia la crittografia
computazionale.\\ 
Si cercher\`a sempre di dare delle definizioni rigorose e il pi\`u possibile non ambigue. 
Si tenter\`a sempre, inoltre, di fornire delle dimostrazioni delle affermazioni che si fanno; \`e questo infatti il giusto modo di procedere.
Non \`e raro infatti, trovare esempi di schemi crittografici che sono stati ritenuti validi solo sulla base di argomentazioni approssimative e non formali e 
che non essendo stati dimostrati \emph{matematicamente} validi si sono poi rivelati tutt'altro che affidabili\footnote{Il cifrario di Vigener\`e ritenuto indecifrabile per 
moltissimi anni si può infatti violare facilmente con tecniche di tipo statistico.}.

\section{L'Avversario}
Il tipico avversario con cui si ha a che fare quando si studiano cifrari o protocolli crittografici nel modello computazionale,
è un avversario con risorse di calcolo \emph{limitate}. Limitate nel senso che si sceglie di porre un limite alla potenza di calcolo dell'avversario.
Questo significa che non avremo a che fare con un avversario che ha una capacit\`a di calcolo potenzialmente infinita o un tempo illimitato a disposizione.\\
Sebbene siano stati ideati cifrari sicuri anche rispetto ad avversari non limitati\footnote{Il cifrario \emph{one-time pad} \`e il tipico esempio di cifrario perfettamente sicuro o teoricamente sicuro.}, 
questi hanno alcuni difetti, come per esempio
il fatto che la chiave debba essere lunga quanto il messaggio o che sia utilizzabile una sola volta.
Per rappresentare in modo formale un avversario con risorse di calcolo limitate, si pu\`o rappresentare questo come un generico algoritmo appartenente ad una 
particolare classe di complessit\`a computazionale\footnote{Un avversario infatti \`e una macchina di Turing che esegue un algoritmo.}. \\
Una linea di pensiero che accomuna ogni campo dell'informatica, considera efficienti gli algoritmi che terminano in un numero di passi polinomiale nella lunghezza dell'input, e inefficienti 
quelli che hanno una complessit\`a computazionale maggiore (e.g. esponenziale). 
La scelta di porre un limite alle risorse di calcolo dell'avversario \`e dettata dal buon senso.
\`E ragionevole infatti pensare che l'attaccante non sia infinitamente potente; \`e altrettanto ragionevole pensare che un attaccante non sia disposto ad impiegare un tempo \emph{eccessivo} per violare uno schema crittografico.\\
\`E logico quindi pensare che gli avversari vogliano essere \emph{efficienti}.\\
Pu\`o sembrare quindi naturale immaginare gli avversari come degli algoritmi che terminano in un numero polinomiale di passi
rispetto alla lunghezza dell'input. Come si pu\`o notare, non si fa alcuna assunzione particolare sul comportamento dell'avversario. Le uniche cose che sappiamo sono che:
\begin{itemize}
 \item l'avversario non conosce la chiave, ma conosce l'algoritmo di cifratura utilizzato  e i parametri di sicurezza, come per esempio la lunghezza della chiave\footnote{Il principio di Kerchoffs 
(famoso crittografo olandese, 19 Gennaio 1835 - 9 Agosto 1903) afferma che
l'algoritmo di cifratura non deve essere segreto e deve poter cadere nelle mani del nemico senza inconvenienti.}. 
 \item l'avversario vuole essere efficiente, ovvero polinomiale.
\end{itemize}

Non si fanno ipotesi sull'algoritmo che questo andr\`a ad eseguire.
Per esempio dato un messaggio cifrato $c=E_k(m)$, non ci aspettiamo che l'avversario non decida di utilizzare la stringa $c'$ tale che:  $c'=D_{k'}(E_k(m))$ con $k\neq k'$. 
Ovvero, sarebbe sbagliato supporre che l'avversario non cerchi di decifrare un messaggio mediante una chiave diversa 
da quella utilizzata per cifrarlo.
Nel modello computazionale i messaggi sono trattati come sequenze di bit e non come espressioni \emph{formali}; l'avversario, nel modello computazionale, pu\`o effettuare qualsiasi operazione su un messaggio. Questa visione \`e, a differenza di quella 
che si ha nel modello formale, sicuramente molto pi\`u realistica~\cite{DBLP:conf/crypto/2006}.\\

Non bisogna per\`o dimenticare che un avversario può sempre \emph{indovinare} il segreto che cerchiamo di nascondere o che cifriamo. 
Per esempio: se il segreto che si cerca di nascondere ha una lunghezza di $n$ bit, l'avversario pu\`o sempre effettuare una scelta casuale fra il valore 0 e il valore 1 per $n$ volte.
La probabilit\`a che l'avversario ottenga una stringa uguale al segreto \`e ovviamente di $\frac{1}{2^n}$. 
Questa probabilit\`a tende a 0 in modo esponenziale al crescere della lunghezza del segreto, ma per valori finiti di $n$ questa probabilit\`a non sar\`a mai 0.
\`E quindi pi\`u realistico cercare di rappresentare l'avversario come un algoritmo che, oltre a terminare in tempo polinomiale, ha
anche la possibilit\`a di effettuare scelte casuali e di commettere errori (anche se con probabilit\`a limitata).
La classe dei problemi risolti da questo tipo di algoritmi \`e indicata con la
sigla \emph{BPP} (i.e. \emph{Bounded Probability Polynomial Time}).\\Un modo pi\`u formale di vedere questo tipo di algoritmi \`e il seguente: si suppone che la macchina di Turing che 
esegue l'algoritmo, oltre a ricevere l'input, diciamo $x$, riceva anche un input ausiliario $r$. Questa stringa di bit $r$, rappresenta una possibile sequenza di lanci di moneta dove \`e stato associato al valore $0$ la croce e al valore $1$ la testa (o anche viceversa ovviamente).
Qualora la macchina dovesse effettuare una scelta casuale, non dovr\`a far altro che prendere il successivo bit dalla stringa $r$, e prendere una decisione in base ad esso
(\`e, in effetti, come se avesse preso una decisione lanciando una moneta). Ecco quindi che il nostro tipico avversario si configura come un algoritmo polinomiale probabilistico.
\`E inoltre giustificato cercare di rendere sicuri\footnote{In qualsiasi modo si possa intendere il concetto di sicurezza. Vedremo che in seguito si daranno delle definizioni rigorose di questo concetto.} gli schemi crittografici rispetto, principalmente, a questo tipo di avversario.
Non \`e quindi necessario dimostrare che un particolare schema crittografico sia inviolabile, ma basta dimostrare che:
\begin{itemize}
 \item in tempi ragionevoli lo si pu\`o violare solo con scarsissima probabilit\`a.
 \item lo si pu\`o violare con alta probabilit\`a, ma solo in tempi non ragionevoli.
\end{itemize}
Sappiamo che il concetto di \emph{tempo ragionevole} \`e catturato dalla classe degli algoritmi polinomiali probabilistici. Vediamo ora di catturare il concetto di \emph{scarsa probabilit\`a}.
\section{Funzioni Trascurabili e non $\dots$}
In crittografia i concetti di \emph{scarsa probabilit\`a} e di evento \emph{raro} vengono formalizzati attraverso la nozione di funzione trascurabile.
\begin{definizione}[Funzione Trascurabile]
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e trascurabile se e solo se per ogni polinomio $p$, esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) < \frac{1}{p(n)}$.  
\end{definizione}
Una funzione trascurabile, quindi, \`e una funzione che tende a 0 pi\`u velocemente dell'inverso di qualsiasi polinomio.
Un'altra definizione utile \`e la seguente:
\begin{definizione}[Funzione Distinguibile]
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e distinguibile se e solo se esiste un polinomio $p$, tale per cui esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) > \frac{1}{p(n)}$.  
\end{definizione}
Per esempio la funzione $n  \mapsto 2^{-\sqrt{n}}$ \`e una funzione trascurabile, mentre la funzione $n \mapsto \frac{1}{n^2}$ non lo \`e. 
Ovviamente esistono anche funzioni che non sono n\'e trascurabili n\'e distinguibili. Per esempio, la seguente funzione definita per casi:\\
$f(n) = \begin{cases} 1, & \mbox{se } n\mbox{ \`e pari} \\ 0, & \mbox{se } n\mbox{ \`e dispari} \end{cases}$\\
non \`e n\'e trascurabile n\'e distinguibile. Questo perch\'e le definizioni precedenti, pur essendo molto legate, non sono l'una la negazione dell'altra.

Se sappiamo che, in un esperimento, un evento avviene con una probabilt\`a trascurabile,
quest'evento si verificher\`a con una probabilit\`a trascurabile anche se l'esperimento viene ripetuto molte volte (ma sempre un numero polinomiale di volte), e quindi per la legge dei grandi numeri, 
con una frequenza anch'essa trascurabile\footnote{In modo informale, la legge debole dei grandi numeri afferma che: per un numero grande di prove, 
la frequenza approssima la probabilit\`a di un evento.}. 
Le funzioni trascurabili, infatti, godono di due particolari propriet\`a di chiusura, enunciate nella seguente:
\begin{proposizione}
Siano $\mu_1, \mu_2$ due funzioni trascurabili e sia $p$ un polinomio. Se $\mu_3 = \mu_1 + \mu_2$, e $\mu_4= p\cdot \mu_1$, allora $\mu_3$, $\mu_4$ sono funzioni trascurabili.  
\end{proposizione} 

Se quindi, in un esperimento, un evento avviene solo con probabilit\`a trascurabile, ci aspettiamo che, anche se ripetiamo l'esperimento un numero polinomiale di volte, questa probabilit\`a
rimanga comunque trascurabile.\\
Per esempio: supponiamo di avere un dado truccato in modo che la probabilit\`a di ottenere 1 sia trascurabile. Allora se lanciamo il dado un numero polinomiale di volte, la probabilit\`a
che esca 1 rimane comunque trascurabile.\\
\`E ora importantissimo notare che:
\textbf{gli eventi che avvengono con una probabilit\`a trascurabile possono essere ignorati per fini pratici}.
In \cite{1206501}, infatti leggiamo:
\begin{quotation}
\emph{Events that occur with negligible probability are so unlikely to occur that can be ignored for all practical purposes. Therefore,
a break of a cryptographic scheme that occurs with negligible probability is not significant.}
\end{quotation}
Potrebbe sembrare pericoloso utilizzare degli schemi crittografici che ammettono di essere violati con probabilit\`a trascurabile, ma questa possibilit\`a \`e cos\`i remota, che una tale preoccupazione \`e da ritenersi
ingiustificata.
Finora abbiamo parlato di funzioni che prendono in input un argomento non meglio specificato. 
Al crescere di questo parametro, le funzioni si comportano in modo diverso, a seconda che siano trascurabili, oppure no.
Ma cosa rappresenta nella realt\`a questo input?
Di solito, questo valore rappresenta un generico parametro di sicurezza, indipendente dal segreto. \`E comune immaginarlo come la lunghezza in bit delle chiavi.\\
D'ora in poi con affermazioni del tipo \flqq\l'algoritmo \`e polinomiale, o esponenziale\frqq, si intenderanno algoritmi polinomiali o esponenziali nella lunghezza (in bit) del parametro di sicurezza (indicato con $n$). Si utilizzer\`a questa assunzione anche quando si faranno affermazioni su funzioni trascurabili o meno. Quelle funzioni saranno trascurabili o meno nel parametro $n$.
Tutte le definizioni di sicurezza che vengono date nel modello computazionale e che utilizzano le probabilit\`a trascurabili, sono di tipo \emph{asintotico}.
Un template di definizione di sicurezza è il seguente \cite{1206501}:
\begin{quotation}
\emph{A scheme is secure if for every probablistic polynomial-time adversary \textbf{A} [...], the probability that \textbf{A} succeds in this attack [...]
is negligible}
\end{quotation}
Essendo questo schema di definizione asintotico (nel parametro di sicurezza \emph{n}), \`e ovvio che non considera valori piccoli di \emph{n}.
Quindi se si dimostra che un particolare schema crittografico \`e sicuro secondo una definizione di questo tipo, pu\`o benissimo capitare che per valori piccoli di \emph{n} lo schema
sia violabile con alta probabilit\`a e in tempi ragionevoli.
\section{Indistinguibilit\`a Computazionale}
Se due oggetti, sebbene profondamente diversi fra loro, non possono essere distinti, allora sono, da un certo punto di vista, equivalenti.
Nel caso della crittografia computazionale, due oggetti sono computazionalmente equivalenti se nessun algoritmo efficiente li pu\`o distinguere.
Possiamo immaginare che un algoritmo riesca a distinguere due oggetti, se quando gli si da in input il primo, lui da in output una costante \emph{c}, mentre se gli si 
fornisce come input il secondo da in output una costante \emph{$c'$} e ovviamente $c \neq c'$.
La definizione tipica di indistinguibilit\`a computazionale \`e data prendendo come oggetti da distinguere alcune particolari distribuzioni statistiche detti \emph{ensembles}.

\begin{definizione}[Ensemble]
Sia $I$ un insieme numerabile infinito. $X=\{X_i\}_{i \in I}$ \`e un ensemble su $I$ se e solo se \`e una sequenza di variabili statistiche, tutte con lo stesso tipo di distribuzione.
\end{definizione}
Un \emph{ensemble} \`e quindi una sequenza infinita di distribuzioni di probabilit\`a\footnote{Siccome si parla di distribuzioni su stringhe di bit con lunghezza finita,
in crittografia computazionale si considerano ensemble che sono una sequenza infinta di distribuzioni finite di stringhe di bit.}. 
Tipicamente le variabili dell'ensemble sono stringhe di lunghezza $i$. $X_i$ \`e quindi una distribuzione di probabilit\`a su stringhe di lunghezza $i$.

Ora supponiamo di avere due ensemble $X$ e $Y$. Intuitivamente queste distribuzioni sono indistinguibili se nessun algoritmo (efficiente) pu\`o accettare infiniti elementi di $X_n$
(per esempio stampando $1$ su input preso da $X_n$) e scartare infiniti elementi di $Y_n$ (per esempio stampare $0$ su input preso da $Y_n$). \`E importante notare che sarebbe facile 
distinguere due \emph{singole} distribuzioni usando un approccio esaustivo, ecco perch\'e si considerano sequenze infinite di distribuzioni finite.
In poche parole questi ensemble sono indistinguibili se ogni algoritmo (efficiente) accetta $x \in X_n$ se e solo se accetta $y \in Y_n$. Ovviamente il \emph{se e solo se} non pu\`o e non deve
essere inteso in senso \emph{classico}, ma deve essere inteso in senso statistico. Poich\'e in crittografia si \`e soliti indicare con $U_m$ una variabile
uniformemente distribuita sull'insieme delle stringhe di lunghezza $m$, chiameremo $U=\{U_n\}_{n \in \mathbb{N}}$ l'ensemble uniforme.
Dopo questa breve introduzione all'indistinguibilit\`a siamo pronti per dare una definizione rigorosa:

\begin{definizione}[Indistinguibilit\`a computazionale]
Due ensemble $X=\{X_n\}$, $Y=\{Y_n\}$ sono computazionalmente indistinguibili se e solo se per ogni algoritmo $D \in BPP$ (detto distinguitore) esiste $\mu$ trascurabile tale che:
\begin{center}$\lvert Pr[D(1^n, X_n) = 1] - Pr[D(1^n, Y_n) = 1] \rvert \leq \mu(n)$.\end{center}
\end{definizione}
Nella definizione precedente: $Pr[D(1^n, X_n) = 1]$ \`e la probabilit\`a che, scegliendo $x$ secondo la distribuzione $X_n$ e fornendo questo valore al distinguitore insieme al valore $1^n$, il distinguitore stampi $1$.
Il fatto che al distinguitore si fornisca anche il valore del parametro di sicurezza in base unaria, serve ad esser sicuri che in ogni caso il distinguitore impieghi un tempo polinomiale 
nel parametro di sicurezza.
Infatti, il distinguitore quando si trover\`a a dover leggere il primo parametro, necessariamente impiegher\`a un tempo polinomiale nel parametro di sicurezza, visto che questo \`e stato 
fornito in base unaria\footnote{Ignoreremo, d'ora in poi, questo cavillo formale.}.

La definizione di indistinguibilit\`a computazionale cattura quindi il seguente concetto: se due ensemble sono computazionalmente indistinguibili, 
allora la probababilit\`a che un distinguitore riesca a discernere i valori provenienti da un insieme rispetto all'altro \`e trascurabile; di conseguenza agli occhi del distinguitore 
gli ensemble non sono differenti e quindi sono per lui equivalenti (o meglio computazionalmente equivalenti o ancora, indistinguibili in tempo polinomiale). 
Non \`e raro, nell'ambito scientifico in particolare, basarsi sul concetto generale di indistinguibilit\`a al fine di creare nuove classi di equivalenza di oggetti.
\begin{quotation}
\emph{The concept of efficient computation leads naturally to a new kind of equivalence between objects: Objects are considered to be computationally equivalent if they cannot be
differentiated by any efficient procedure. We note that considering indistinguishable objects as equivalent is one of the basics paradigms of both science and real-life situations. Hence,
we believe that the notion of computational indistinguishability is a very natural one~\cite{519078}.}
\end{quotation}


\section{Pseudocasualit\`a e Generatori Pseudocasuali}
Argomento centrale di questa sezione \`e il concetto di \emph{pseudocasualit\`a} applicato a stringhe di bit di lunghezza finita.
Parlare di pseudocasualit\`a applicata ad una \emph{singola} stringa, ha poco senso quanto ne ha poco parlare di singola stringa casuale.
Il concetto di casualit\`a (come quello di pseudocasualit\`a) si applica, infatti, a distribuzioni di oggetti (stringhe di bit nel nostro caso) e non a singoli oggetti.\\
La nozione di casualit\`a \`e fortemente legata a quella di distribuzione uniforme. Un insieme di oggetti \`e caratterizzato
da una distribuzione uniforme se la probabilit\`a \`e equamente distribuita su tutti gli oggetti. Quindi \emph{l'estrazione} di un elemento \`e del tutto casuale, 
perch\'e non ci sono elementi pi\`u probabili di altri.

Il concetto di pseudocasualit\`a \`e un caso particolare di indistinguibilit\`a, infatti una distribuzione \`e \emph{pseudocasuale} se nessuna procedura efficiente, 
pu\`o distinguerla dalla distribuzione uniforme.
\begin{definizione}[Pseudocasualit\`a]
L'ensemble $X=\{X_n\}_{n \in \mathbb{N}}$ \`e detto pseudocasuale se e solo se $ \exists l:$ $\mathbb{N}\rightarrow\mathbb{N}$ tale che: 
$X$ \`e computazionalmente indistinguibile da $U=\{U_{l(n)}\}_{n \in \mathbb{N}} $.  
\end{definizione}
Data questa definizione, possiamo finalmente definire formalmente cosa sia un generatore pseudocasuale.
\begin{definizione}[Generatore Pseudocasuale]
Sia $l:$ $\mathbb{N}\rightarrow\mathbb{N}$ un polinomio detto fattore d'espansione. 
Sia G un algoritmo polinomiale deterministico tale che: $\forall s \in \{0, 1\}^{n}$ $G(s) \in \{0, 1\}^{l(n)}.$
Allora $G$ \`e un generatore pseudocasuale se e solo se valgono le seguenti condizioni:
\begin{itemize}
 \item Espansione: $\forall n: l(n) > n$
 \item Pseudocasualit\`a: $\forall D \in BPP, \exists \mu$ trascurabile tale che \begin{center}
                                                   $\lvert Pr[D(r) = 1] - Pr[D(G(s)) = 1]\rvert$                               
                                                                                 \end{center} 
con $r \in U_{l(n)}$ e $s \in U_{n}$
\end{itemize}
\end{definizione}

Quindi: se data una stringa di bit $s \in U_{n}$, nessun distinguitore efficiente riesce a distinguere (con una probabilit\`a non trascurabile) $G(s)$ da una stringa $r \in U_{l(n)}$, allora 
$G$ \`e un generatore pseudocasuale. Il suo output, infatti, non \`e distinguibile dalla distribuzione effettivamente uniforme.

\`E importante per\`o notare, che la distribuzione di stringhe in output di un generatore pseudocasuale \`e fortemente differente dalla distribuzione effettivamente casuale. Per rendere pi\`u chiara questa distinzione procederemo
con un importante esempio.
Supponiamo di avere un generatore pseudocasuale \emph{G} con fattore d'espansione $l(n)=2n$.
L'insieme $A=\{0, 1\}^{2n}$ ha, ovviamente, una cardinalit\`a pari a $2^{2n}$. Fissando quindi una certa stringa $x \in A$, 
questa ha una probabilit\`a di esser scelta in maniera casuale pari a: $\frac{1}{\lvert A \rvert} = \frac{1}{2^{2n}}$.

Ragioniamo adesso sull'output del generatore $G$. Questo prende un input appartenente al dominio: $B=\{0, 1\}^{n}$. 
Anche considerando il caso \emph{migliore} di un generatore iniettivo\footnote{Una generica funzione $f$ \`e iniettiva se e solo se $\forall x_1, x_2:$ $x_1 \neq x_2 \Rightarrow f(x_1) \neq f(x_2)$.},
il codominio di $G$ avr\`a una cardinalit\`a pari a quella del dominio ovvero $2^{n}$. La maggior parte degli elementi dell'insieme $A$ non ricadr\`a 
nell'output di $G$; questo a causa dell'abissale differenza di cardinalit\`a fra gli insiemi $G(B)$ e $A$.
Quindi la probabilit\`a che una stringa scelta in maniera uniforme dall'insieme $A$ ricada nel codominio di $G$ \`e di $\frac{2^{n}}{2^{2n}}$, cio\`e $2^{-n}$.
In teoria, quindi, \`e facile immaginare un distinguitore $D$ che riesca a discernere l'output di $G$ dalla distribuzione uniforme con probabilit\`a non trascurabile.
Supponiamo che $D$ prenda in input $y \in A$. Tutto ci\`o che $D$ deve fare \`e ricercare in modo esaustivo un $w \in B$ tale che $G(w) = y$.
Se $y \in G(B)$ allora $D$ se ne accorger\`a con probabilit\`a 1, mentre se $y$ \`e stato scelto in maniera uniforme dall'insieme $A$, $D$ stamper\`a 1 con probabilit\`a $2^{-n}$. 
\newpage Quindi abbiamo che:
\begin{center}
$\lvert Pr[D(r)=1] - Pr[D(G(s))=1]\rvert \geq 1 - 2^{-n}$
\end{center} 
con $r \xleftarrow{R} A$ e $s \xleftarrow{R} B$~\footnote{Con la notazione $s \xleftarrow{R} O$, si intende la scelta dell'elemento 
$s \in O$ in maniera casuale.}.\\
Il membro a destra della disequazione \`e una funzione distinguibile. Sembrerebbe quindi che $G$ non sia un generatore pseudocasuale.
C'\`e un' importante constatazione da fare per\`o. Il distinguitore $D$ non \`e efficiente! Infatti impiega un tempo esponenziale nel parametro $n$, e non polinomiale.
La distribuzione generata da $G$ dunque, \`e si ben lontana dall'essere uniforme, ma questo non \`e importante dal momento che nessun distinguitore che viaggia in tempo polinomiale pu\`o 
accorgersene.


Nella pratica lo scopo di $G$ \`e prendere in input un $seed$ casuale, e da quello generare una variabile pseudocasuale molto pi\`u lunga. Si intuisce da questo la grandissima
importanza che hanno i generatori pseudocasuali in crittografia. Per esempio il seed potrebbe corrispondere alla chiave di un cifrario, mentre l'output di $G$ di lunghezza $k$ potrebbe
essere il valore con cui viene fatto lo $XOR$ del messaggio (anch'esso di lunghezza $k$); otteniamo cos\`i una versione del one-time pad basato su una chiave pi\`u corta del messaggio.
Siccome una stringa pseudocasuale appare, ad un distinguitore efficiente $D$, come una stringa casuale, $D$ non ottiene un vantaggio sensibile nel passaggio dal vero one-time pad
al one-time pad che usa una chiave pseudocasuale. In generale i generatori pseudocasuali sono molto utili in crittografia per creare schemi crittografici simmetrici.

\section{Dimostrazioni Basate su Games}
In questo paragrafo si cercher\`a di spiegare cosa siano, nell'ambito della crittografia, i \emph{games}\footnote{Che intenderemo letteralmente come "giochi".} e come siano strutturate la
maggior parte delle dimostrazioni che utilizzano sequenze di games.\\Si possono trovare approfondimenti riguardo a questi concetti nel lavoro di Shoup \cite{shoup}.
Quella basata sul concetto di game \`e una tecnica\footnote{Game hopping technique.} molto utilizzata per provare la sicurezza di primitive crittografiche o di protocolli crittografici.
Questi games sono giocati da un' ipotetica entit\`a maligna, l'attaccante, e da un'ipotetica parte benigna di solito chiamata sfidante\footnote{Perch\`e \emph{sfida} l'attaccante a 
vincere questo gioco.}. 
\`E difficile dare una definizione formale di game; infatti il concetto di game cambia, sebbene in maniera non considerevole, da situazione a situazione, da ambiente ad ambiente e 
da dimostrazione a dimostrazione (sia che queste siano fatte manualmente, sia che queste siano automatiche e quindi dipendenti dal framework in cui vengono costruite).
Intuitivamente per\`o, i game possono essere immaginati come un insieme di azioni, modellate in una particolare algebra di processi, 
che servono a specificare il comportamento dei partecipanti al gioco, ovvero le entit\`a che partecipano come \emph{principals} al protocollo crittografico.\\
Il lettore trover\`a utile pensarli, almeno nell'ambito di questa tesi, come insiemi di processi che, fra le altre cose, forniscono un'interfaccia all'attaccante attraverso degli 
\emph{oracoli} che possono resitituire dei valori all'attaccante. Questi oracoli, prima di restituire il valore, possono effettuare calcoli, dichiarare ed utilizzare variabili che non saranno
visibili all'esterno.\\Si deve pensare agli oracoli come a delle scatole nere inaccessibili dall'esterno. Questi oracoli, una volta interrogati, forniscono una risposta,
e questo \`e il massimo livello di interazione che dall'esterno si pu\`o avere con queste entit\`a.\\ \\
Il primo passo che le dimostrazioni di sicurezza basate su sequenze di game fanno, \`e quello di modellare il protocollo crittografico reale in un game iniziale $G_0$.
In $G_0$ esiste la probabilit\`a non nulla che un evento \emph{negativo} possa accadere (immaginiamolo come una sorta di vittoria da parte dell'attaccante).
Ora, in generale, si procede effettuando delle modifiche al game $G_i$ ottenendo un game $G_{i+1}$ 
tale che $G_i$ e $G_{i+1}$ siano computazionalmente indistinguibili. Le modifiche che si effettuano fra un game e un altro devono introdurre delle differenze computazionalmente irrilevanti.
Queste modifiche possono essere viste come regole di riscrittura delle distribuzioni di probabilit\`a delle variabili in gioco nei games.
Se, per esempio, in un game $G_i$ un processo ha a che fare con un variabile casuale, e nel game $G_{i+1}$ questa viene sostituita con una variabile che invece \`e pseudocasuale, non vengono introdotte
modifiche computazionalmente rilevanti e quindi il passaggio \`e lecito, visto che i due games non sono distinguibili se non con probabilit\`a trascurabile.
Alla fine si arriva ad un game $G_f$ in cui \emph{l'evento} non pu\`o accadere. Se l'evento non pu\`o accadere, l'attaccante non ha possibilit\`a di vincere. 
Se, quindi, nel game finale l'attaccante non ha possibilit\`a di vincere e il game finale
\`e computazionalmente indistinguibile dal penultimo, questo lo \`e dal terzultimo e cos\`i via fino a $G_0$, allora
il game finale \`e computazionalmente indistinguibile dal primo\footnote{Ricordiamo infatti che la somma di due probabilit\`a trascurabili rimane trascurabile.}. 
Adesso, quindi, se nel game iniziale esiste la possibilit\`a che un evento avvenga, e nel game finale no,
si pu\`o dare un limite superiore alla probabilit\`a che l'evento avvenga nel game iniziale. Questo limite \`e la somma di tutte le probabilit\`a con cui un attaccante riesce a distinguere un game dal successivo all'interno della sequenza.

\`E importante dire che anche nel modello formale si possono utilizzare le sequenze di game. La differenza \`e che due games successivi non sono computazionalmente indistinguibili, 
ma sono perfettamente indistinguibili. In particolare quello che si vuole sottolineare \`e che se in una sequenza di game $G_b$ e $G_a$ sono l'uno il successore dell'altro, 
allora i due game 
devono appartenere ad una stessa classe di equivalenza che \`e indotta dalla particolare relazione di equivalenza che il modello in cui si sta costruendo la catena di game sfrutta.
Nel modello formale questa relazione sar\`a l'indistinguibilit\`a perfetta (meglio nota come equivalenza osservazionale) mentre in quello computazionale sar\`a 
l'indistinguibilit\`a computazionale.
\chapter{CryptoVerif}
CryptoVerif \`e un \emph{dimostratore} automatico di sviluppo abbastanza recente\footnote{La sua prima release stabile risale al 2006.} che lavora direttamente nel modello computazionale.\\
CryptoVerif \`e stato scritto da Bruno Blanchet\footnote{Ricercatore al LIENS (Computer Science Laboratory of Ecole Normale Supérieure)} nel linguaggio di programmazione OCaml. 
Si possono trovare pi\`u informazioni riguardo al tool nella home page di Blanchet\footnote{\url{http://www.di.ens.fr/~blanchet/index-eng.html}}.
Questo tool \`e utilizzato per dimostrare propriet\`a di segretezza e autenticazione. Le prove in questione  si basano sulla tecnica delle sequenze di game.
Il tool \`e liberamente scaricabile\footnote{\url{http://www.cryptoverif.ens.fr/cryptoverif.html}} sotto la licenza CeCill\footnote{\url{http://www.cecill.info/licences/}}.
CryptVerif \`e stato gi\`a utilizzato per dimostrare la correttezza di alcuni protocolli crittografici, come per esempio: FDH \cite{BlanchetPointchevalCrypto06}, 
Kerberos \cite{BlanchetJaggardScedrovTsayAsiaCCS08}.\\
Scopo di questo capitolo \`e quello di descrivere, in modo non troppo formale\footnote{Nel senso che la semantica formale non sar\`a trattata rigorosamente. Il lettore interessato all'argomento pu\`o comunque trovare pi\`u informazioni in \cite{BlanchetJaggardScedrovTsayAsiaCCS08}}, 
un sottoinsieme del linguaggio che CryptoVerif implementa, in modo 
da poter leggere il capitolo successivo con le conoscenze necessarie.
Alla fine del capitolo verr\`a descritta brevemente l'implementazione dello schema di firma FDH nel linguaggio di CryptoVerif.
\newpage
\section{La Sintassi}
Un tipico file di input per CryptoVerif ha la seguente forma: \begin{verbatim}
<declaration>* process <odef>.
\end{verbatim}                                                       
Si cercher\`a di fornire maggiori spiegazioni senza per\`o, per ora, entrare troppo nel dettaglio.
Una dichiarazione (declaration) serve a CryptoVerif per avere delle informazioni su come comportarsi nella dimostrazione; 
spesso \`e una descrizione di una primitiva crittografica che CryptoVerif pu\`o assumere come vera per costruire le sue prove.
In generale una dichiarazione pu\`o essere:
\begin{description}
 \item{\emph{Simbolo funzionale}.} La dichiarazione di una funzione viene insieme ai tipi dei parametri in input (se ce ne sono) e il tipo del valore di ritorno. Per esempio, con il seguente codice:\\
				      \begin{verbatim}
				       fun kgen(keyseed):key.
				      \end{verbatim}	   
si dichiara una funzione \verb!kgen: keyseed!$\rightarrow$ \verb!key!. Intuitivamente il simbolo $\texttt{kgen}$ rappresenta una funzione per generare chiavi crittografiche a partire da un seme casuale.
 \item{\emph{Tipo}.} L'utente pu\`o definire dei propri tipi i cui valori saranno comunque trattati come stringhe di bit,
	    ovvero come sottoinsiemi di $\{0, 1\}^*$. Per esempio, con il seguente codice:
  				      \begin{verbatim}
				       type keyseed[fixed].
				      \end{verbatim}
si dichiara un nuovo tipo $\texttt{keyseed}$. La parola chiave $\texttt{fixed}$ serve per informare CryptoVerif che deve essere possibile estrarre valori casuali da quell'insieme.
Un'altra opzione molto utilizzata \`e $\texttt{large}$. Un tipo dichiarato come $\texttt{large}$ gode della propriet\`a che, scegliendo casualmente due valori dal dominio del tipo, la probabilit\`a di ottenere
due valori identici \`e trascurabile.
 \item{\emph{Propriet\`a}.} \`E possibile modellare alcune propriet\`a dei simboli di funzione che si specificano, come per esempio l'iniettivit\`a oppure la monotonia. Per esempio, con il seguente codice:
    				      \begin{verbatim}
				    forall x, y: myType; (f(x) = f(y)) = (y = x).
				      \end{verbatim}
definiamo l'iniettivit\`a della funzione $\texttt{f}$. Infatti possiamo sostituire il membro a sinistra dell'equazione con quello di destra solo se la funzione \`e $\texttt{f}$ iniettiva.
 \item{\emph{Regola di Riscrittura}.} Una dichiarazione di una regola di riscrittura consiste in una coppia di espressioni. Ogni qualvolta CrytptoVerif incontra la prima
			      pu\`o decidere di sostituirla con la seconda. Per esempio, con il seguente codice:
      				      \begin{verbatim}
				      not(not(true))=false.
				      not(not(false))=true.
				      \end{verbatim}
informiamo CryptoVerif che ogni qualvolta incontra una doppia negazione del valore true pu\`o sostituirlo con il valore false, e viceversa. 
Si badi che se si dessero, invece delle precedenti, queste regole di riscrittura:
				      \begin{verbatim}
				      false=not(not(true)).
				      true=not(not(false)).
				      \end{verbatim}
si andrebbe incontro ad un probabile loop infinito durante la fase di elaborazione di CryptoVerif. Infatti nel momento in cui il tool riconoscesse nel codice il valore $\texttt{true}$, 
procederebbe con una riscrittura di questo nel frammento $\texttt{not(not(false))}$ il quale a sua volta sarebbe riscritto in $\texttt{not(not(not(not(true))))}$ e cosi via senza poter mai terminare.
 \item{\emph{Probabilit\`a}.} In CryptoVerif \`e possibile dichiarare delle probabilit\`a. Le probabilit\`a non solo possono essere usate come \emph{oggetti} 
		      a se stanti, ovvero come dei valori statici, ma possono anche essere utilizzate come funzioni di altri argomenti. Con il seguente codice:
				      \begin{verbatim}
				      proba POW.
				      \end{verbatim}
si dichiara una probabilit\`a POW. 
 \item{\emph{Costante}.} Dichiarando una costante $\texttt{k}$ si dice a CryptoVerif che quel dato, una volta inizializzato, non pu\`o cambiare di valore durante l'esecuzione del protocollo. Per esempio, con il seguente codice:
				      \begin{verbatim}
				      const mark:bitstring.
				      \end{verbatim}
	Si dichiara una costante chiamata $\texttt{mark}$ di tipo $\texttt{bitstring}$.
 \item{\emph{Evento}.} Un evento permette di rappresentare alcune particolari situazioni nel flusso d'esecuzione di un protocollo. Per esempio si potrebbe
		pensare di dichiarare un evento \emph{forge} da \emph{sollevare} nel momento in cui un avversario riesca a \emph{forgiare} una firma
		valida per un messaggio. Per esempio, con il seguente codice:
				      \begin{verbatim}
				      event forge.
				      \end{verbatim}
	      si dichiara un evento forge. Si osservi il seguente codice: 
 				      \begin{verbatim}
   find u <= qS suchthat defined(m[u]) && (m' = m[u]) then 
       end
   else      
      event forge.

				      \end{verbatim}
nel ramo else viene sollevato l'evento forge. Infatti, come sar\`a meglio spiegato nel paragrafo relativo all'esempio FDH, il ramo else rappresenta la situazione in cui un avversario ha fornito
una coppia $\texttt{(m,} $ $\sigma \texttt{)}$ tale che $\sigma$ \`e una firma valida per il messaggio $\texttt{m}$ e nessun oracolo ha mai rilasciato tale firma.
 \item{\emph{Equivalenza}.} Una dichiarazione di un'equivalenza fra game permette di dare a CryptoVerif una regola di riscrittura che pu\`o valere
		    a meno di una certa probabilit\`a. Affermando che un game \`e equivalente ad un altro a meno di una certa probabilit\`a, 
		    si d\`a la possibilit\`a al tool di sostituire espressioni che compaiono nel primo game con le equivalenti che compaiono nel secondo, 
tenendo comunque conto della probabilit\`a in gioco.
Per esempio, con il seguente codice:
\newpage
\begin{verbatim}
equiv 
      foreach iK <= nK do r <-R seed; (
          Opk() := return(pkgen(r)) |
          foreach iF <= nF do x <-R D;
           (Oant() := return(invf(skgen(r),x)) |
            Oim() := return(x)
               )
           )
   <=(0)=>
      foreach iK <= nK do r <-R seed; (
         Opk() := return(pkgen(r)) |
         foreach iF <= nF do x <-R D;
          (Oant() := return(x) |
                   Oim() := return(f(pkgen(r), x))
              )
          )
 \end{verbatim}
si definisce un'equivalenza fra game che permette di definire la funzione $\texttt{invf}$ come l'inversa di $\texttt{f}$. Poich\`e quest'affermazione non vale a meno di una probabilit\`a ma \`e vera sempre
la quantit\`a tra parentesi \`e zero (fra i due game). Si possono per\`o specificare, come si vedr\`a successivamente, delle equivalenze fra game che valgono a meno di una certa probabilit\`a.
 \item{\emph{Parametro}.} Un parametro (di cui si sa solo che assumer\`a valori polinomiali nel parametro di sicurezza) pu\`o essere utilizzato per vari scopi.
		  Il pi\`u importante \`e sicuramente effettuare lookup in array che contengono un numero di oggetti pari al parametro.
Per esempio, con il seguente codice:
\begin{verbatim}
param qS.
\end{verbatim}
si dichiara un parametro $\texttt{qS}$ di cui sappiamo che assumer\`a valori polinomiali nel parametro di sicurezza.	    
 \item{\emph{Oracolo}.} \`E possibile dichiarare oracoli aggiuntivi che successivamente possono essere richiamati durante l'esecuzione
			  del protocollo crittografico. Un oracolo in CryptoVerif non \`e altro che un processo il quale pu\`o prendere
			  dei dati in input e restituirne in output. Un oracolo pu\`o, nel suo corpo, effettuare dei calcoli i quali devono
			  essere considerati invisibili per un ipotetico attaccante. Per esempio, con il seguente codice:
 \begin{verbatim}
   let processS =
     foreach iS <= qS do
     OS(m:bitstring) :=
      return(invf(sk, hash(m))).
 \end{verbatim}
si dichiara un processo $\texttt{processS}$ che non \`e altro che la replicazione, limitata polinomialmente dal parametro $\texttt{qS}$, dell'oracolo $\texttt{OS}$.
 \item{\emph{Query}.} Mediante un'istruzione di query \`e possibile istruire il tool su cosa si vuole venga dimostrato. Per esempio \`e possibile richiedere
		    al tool di dimostrare l'indistinguibilit\`a di una variabile da un oggetto casuale, provandone cos\`i la pseudocasualit\`a.	Per esempio, con il seguente codice:
\begin{verbatim}
 query secret1 x.
\end{verbatim}
si chiede a CryptoVerif di cercare di dimostrare che $x$ \`e indistinguibile da una stringa casuale.
\end{description}



Di solito la maggior parte delle dichiarazioni (o comunque quelle pi\`u importanti e utilizzate) vengono fornite a CryptoVerif in un file separato (una sorta di libreria, specificata da linea di comando
mediante l'opzione \\-lib\footnote{Per maggiori informazioni si pu\`o leggere il manuale del tool liberamente scaricabile dallo stesso url del tool.}). 
Grazie a questa possibilit\`a \`e possibile dare una volta per tutte alcune definizioni molto utili in crittografia (e.g funzione one-way). 
Una volta date \`e possibile utilizzarle in tutti gli schemi crittografici che le utilizzano semplicemente specificando il file di libreria corretto.\\
Dopo una serie di dichiarazioni si procede inserendo la parola chiave $\texttt{process}$ e si continua specificando mediante un oracolo il protocollo di cui si desiderano dimostare delle propriet\`a. 
In CryptoVerif, come gi\`a detto, un oracolo non \`e altro che un processo o un' opportuna composizione di processi. 
I processi sono specificati mediante un calcolo di processi; questo mette a disposizioni vari operatori per comporre in vario modo dei processi di base, al fine di ottenere
ancora dei processi. Per esempio, dati due processi $A$ e $B$ \`e possibile ottenere un altro processo $A|B$ (leggasi $A$ parallelo $B$) in cui i due processi
sono eseguiti in parallelo; oppure \`e possibile ottenere il processo $A;B$ che \`e un processo che esegue $A$ e poi esegue $B$. \`E possibile inoltre avere
un particolare tipo di parallelismo in cui si crea un numero di copie, limitato polinomialmente, di un particolare processo (in questo CryptoVerif
si \`e sicuramente ispirato al precedente calcolo di processi che si pu\`o trovare in \cite{MitchellRST06} quest'ultimo ispiratosi a sua volta
a \cite{AbadiG99} introducendo per\`o la fondamentale nozione di replicazione limitata polinomialmente). I processi nell'ambito della descrizione dei protocolli crittografici
devono essere intesi come le entit\`a che nel mondo reale utilizzano il protocollo stesso. Se per esempio un protocollo prevede che un utente $A$ spedisca un messaggio cifrato ad un 
utente $B$ si pu\`o pensare di modellare sia $A$ che $B$ attraverso due processi separati. Attraverso la grammatica in BNF che segue possiamo descrivere in modo pi\`u formale 
la composizione di oracoli.\\
\begin{verbatim}
<odef> ::= <ident>
        | (<odef>)
        | 0
        | <odef> | <odef>
        | foreach <ident> <= <ident> do <odef>
        | <ident> (seq <pattern> ) := <obody>
\end{verbatim} 
Si noti la terza produzione in cui si specifica che l'oracolo \emph{nullo} (ovvero quello che non fa nulla) \`e un oracolo valido. O ancora, un oracolo pu\`o essere la composizione parallela di
pi\`u oracoli o la replica limitata (mediante il $\texttt{foreach}$) di un altro oracolo. Il fatto che un oracolo possa essere composto in maniera sequenziale con un altro oracolo
verr\`a spiegato meglio a breve.


Abbiamo parlato di modi di comporre oracoli per ottenere altri oracoli; non abbiamo per\`o descritto cosa pu\`o fare un oracolo, in particolare non si \`e 
descritto come questi siano costruiti.
\\Un oracolo come gi\`a detto \`e un processo e come tale pu\`o fare delle operazioni.
Le operazioni che pu\`o fare sono varie, infatti pu\`o:
\begin{itemize}
 \item terminare.
 \item ritornare un valore al chiamante (che pu\`o essere anche l'attaccante).
 \item sollevare un evento.
 \item assegnare ad una variabile un valore, il quale pu\`o essere anche un risultato restituito da un altro oracolo
 \item assegnare ad un variabile un valore scelto casualmente da un particolare dominio.
 \item avere comportamenti diversi a seconda dell'esito di un test.
 \item ricercare valori all'interno di un array di valori.
\end{itemize}
Il corpo di un oracolo pu\`o essere descritto in maniera pi\`u formale attraverso la seguente grammatica in BNF:

\begin{verbatim}
obody ::= <ident>
          | ( <obody> )
          | end
          | event <ident> [(seq <term> )] [; <obody> ]
          | <ident> <-R <ident> [; <obody> ]
          | <ident> [: <ident> ] <- <term> [; <obody> ]
          | let <pattern> = <term> [in <obody> [else <obody> ]]
          | if <cond> then <obody> [else <obody> ]
          | find [[unique]] <findbranch> (orfind <findbranch> )∗ 
                    [else <obody> ]
          | return(seq <term> )[; <odef> ]
\end{verbatim}
Si noti come dopo un $\texttt{return}$, mediante il simbolo di sequenzializzazione (il simbolo ``;``), sia possibile definire un oracolo che verr\`a eseguito dopo quello precedente.
\`E importante notare il costrutto $\texttt{let}$ con il quale \`e possibile cercare di decomporre il valore a destra del simbolo di uguaglianza in un pattern specificato e, 
a seconda che questa decomposizione abbia o meno successo, \`e possibile richiamare un oracolo o un altro. 
Un pattern pu\`o essere:
\begin{itemize}
 \item una variabile.
 \item una funzione (eventualmente applicata a degli argomenti).
 \item una tupla di valori. 
\end{itemize}
Per esempio, con il codice:
\begin{verbatim}
 let x = A(r) in
 return(x) 
\end{verbatim}
non si fa altro che assegnare ad $\texttt{x}$ (il cui tipo viene inferito dal tipo di ritorno di $\texttt{A}$) il valore che la funzione $\texttt{A}$ ritorna su input $\texttt{r}$ per poi ritornare il valore $\texttt{x}$.
Si noti che se, come nel caso precedente, il pattern \`e una variabile, l'effetto, da un punto di vista pratico, \`e un semplice assegnamento di un valore ad una variabile.
Questo assegnamento ha sempre successo, e degenera quindi in una dichiarazione e inizializzazione di una variabile il cui \emph{scope} \`e l'oracolo che si trova dopo la parola chiave $\texttt{in}$; 
se il pattern \`e una variabile quindi, il ramo $\texttt{else}$ non viene mai eseguito.
Come gi\`a accennato \`e possibile assegnare dei valori scelti in maniera casuale a delel variabili. Se per esempio $\texttt{x}$ \`e una variabile e $\texttt{D}$ \`e un tipo dichiarato
con la clausola $\texttt{fixed}$, allora il seguente codice:
\begin{verbatim}
 x <-R D;
\end{verbatim}
assegna ad $\texttt{x}$ un valore scelto in maniera casuale da $\texttt{D}$. \\
L'assegnamento non casuale invece ha la seguente forma:
\begin{verbatim}
  x:Type <- G(r);
 \end{verbatim}
con il codice precedente si dichiara $\texttt{x}$ come variabile di tipo $\texttt{Type}$ e si assegna a questa il valore ritornato dalla funzione $\texttt{G}$.
Si osservi ora come nel seguente frammento di codice:
\begin{verbatim}
MyOracle() :=
    r <-R A;
    x:MyType <- f(r);
    return(x);
    (Z | X | Y)
\end{verbatim}
venga definito il corpo dell'oracolo $\texttt{MyOracle}$. In questo per prima cosa si assegna alla variabile $\texttt{r}$ un valore scelto casualmente dall'insieme dei valori di $\texttt{A}$,
successivamente si assegna alla variabile $\texttt{x}$ il valore resitutito dalla funzione $\texttt{f}$ applicato al valore $\texttt{r}$, infine si ritorna il valore $\texttt{x}$, successivamente viene eseguito un altro processo
che \`e il risultato della composizione in parallelo dei processi $\texttt{Z}$, $\texttt{X}$ e $\texttt{Y}$. 


Un costrutto fondamentale del linguaggio implementato da CryptoVerif \`e il costrutto $\texttt{find}$ (come si afferma anche in \cite{BlanchetPointchevalCrypto06} \`e probabilmente il maggior apporto 
fornito da questo tool rispetto ad altri linguaggi che lavorano invece su liste) 
che permette di effettuare un lookup su un array alla ricerca di un elemento che soddisfa particolari propriet\`a, e compiere azioni diverse a seconda che 
questo elemento venga trovato o meno. Un tipico esempio di utilizzo del costrutto $\texttt{find}$ pu\`o essere analizzato nel seguente frammento di codice:
\begin{verbatim}
 let processT =
      OT(m':bitstring, s:D) :=
      if f(pk, s) = hash(m') then
      find i <= qS suchthat defined(m[i]) && (m' = m[i]) then 
          end 
      else
          event forge.
\end{verbatim}
in questo frammento viene definito un processo $\texttt{processT}$ come un oracolo $\texttt{OT}$ che prende in input degli argomenti e che, quando viene chiamato, effettua un test e se questo \`e positivo esegue il ramo
$\texttt{then}$ dell'$\texttt{if}$. Nel ramo $\texttt{then}$ viene effettuata una ricerca nell'array $\texttt{m}$ mediante il contatore $\texttt{i}$. Se viene trovato un $\texttt{i}$ tale per cui l'iesimo elemento dell'array $\texttt{m}$ \`e definito (ovvero gli \`e stato
precedentemente assegnato un valore) e tale per cui l'iesimo elemento dell'array ha un valore uguale al valore fornito in input, allora viene eseguito il ramo $\texttt{then}$ del $\texttt{find}$ che \`e semplicemente
la terminazione dell'oracolo.
Il costrutto $\texttt{find}$ permette anche la scansione di diversi array, ovvero si pu\`o effettuare una ricerca all'interno di diversi array cercando elmenti che verifichino diverse condizioni.
Se diverse condizioni vengono verificate e quindi c'\`e la possibilit\`a che debbano essere eseguiti diversi rami $\texttt{then}$ ognuno associato con condizioni diverse allora CryptoVerif 
ne sceglie uno casualmente ed esegue quello.


\section{Tecnica di dimostrazione}
Come gi\`a detto in precedenza CryptoVerif basa le sue prove sulla tecnica delle sequenze di game. Infatti CryptoVerif parte da un game iniziale fornito dall'utente e mediante equivalenze, che possono o meno
introdurre differenze, cerca di modificare un game in un altro fino ad arrivare ad un game finale che soddisfi le richieste fatte dall'utente. Questa tecnica \`e basata innanzi tutto su una 
particolare relazione di cui a breve si dar\`a una definizione. Prima di darla un po' di notazione. \\
\begin{definizione}[Equivalenza Osservazionale relativa alla probabilit\`a $p$]
Siano $Q$ e $Q^{'}$ due processi allora $Q$ e $Q{'}$ sono osservazionalmente equivalenti relativamente a $p$ (indicheremo la relazione con il simbolo $\approx_p$) se e solo se $\forall t, C$
\end{definizione}
Questa relazione d'equivalenza gode di alcune propriet\`a interessanti fra cui le seguenti:
\begin{enumerate}
 \item \emph{Se $Q \approx_p Q^{'}$ e $Q^{'} \approx_p^{'} Q^{''}$ allora $Q \approx_{p+p^{'}} Q^{'} $}
 \item \emph{Se Q esegue un evento $e$ con probabilit\`a al massimo $p$ e $Q \approx_p Q^{'}$ allora $Q^{'}$ esegue l'evento $e$ con probabilit\`a al massimo $p+p^{'}$}
\end{enumerate}

Quindi CryptoVerif, in generale, parte da una game $G_0$ che corrisponde ad un protocollo reale (di cui si vuole provare qualche propriet\`a) e costruisce una sequenza di game 
osservazionalmente equivalenti fra loro: $G_0 \approx_{p_1} G_1 \approx_{p_2} G_2 \dots \approx_{p_f} G_f $; data questa sequenza, attraverso le propriet\`a 1 e 2, conclude che
$G_0  \approx_{\sum_{p=1}^{f}} G_f $.


\section{Un Esempio: FDH}
\emph{Full Domain Hash} \`e uno schema di firma che segue il paradigma \emph{hash-and-sign}\footnote{Questo paradigma vuole che: dato un messaggio $m$ se ne ritorni 
la firma di $hash(m)$ e non la firma di $m$, dove la funzione hash pu\`o essere istanziata con qualsiasi funzione hash collision resistant. 
Si ottiene cos\`i una firma di lunghezza fissa e non dipendente dalla lunghezza del messaggio}. 
Quella che a breve seguir\`a \`e la descrizione dello schema di firma FDH nel linguaggio di CryptoVerif. In quest'esempio la funzione $f$ sar\`a la funzione la cui inversa
viene utilizzata per firmare messaggi, mentre la funzione $hash$ sar\`a la funzione utilizzata per ottenere un'hash di una stringa di bit.\\
L'input che si fornisce al CryptoVerif \`e costituito, fondamentalmente, da due parti: 
\begin{itemize}
 \item Un game iniziale $G_0$, in cui si modella la sicurezza dello schema.
 \item Alcune equivalenze necessarie a CryptoVerif per effettuare le modifiche ai games. 
\end{itemize}
La descrizione dello schema di firma FDH viene data al CryptoVerif attraverso il seguente game $G_0$:

\begin{verbatim}
foreach iH <= qH do   
  OH(x : bitstring) := return(hash(x)) |
  Ogen() := r <-R seed;     
    pk <- pkgen(r );    
    sk <- skgen(r );       
    return(pk ); (
    foreach iS <= qS do 
         OS(m : bitstring) := return(invf(sk , hash(m))) |
         OT (m1 : bitstring, s : D) := if f(pk , s) = hash(m1 ) then
             find u <= qS suchthat (defined(m[u]) && m1 = m[u]) then
                  end
             else
                  event forge
)         
\end{verbatim}

Procediamo adesso con una breve spiegazione di questo game.
Possiamo vedere come in questo game si forniscano $\texttt{qH}$ copie dell' oracolo $\texttt{OH}$ le quali ritornano l'hash della stringa che gli si fornisce in input, ovvero $\texttt{x}$.\\
Abbiamo poi l'oracolo $\texttt{Ogen()}$ che ritorna al contesto una chiave pubblica dopo aver creato, partendo da un seme casuale, una coppia costituita da una chiave privata e una chiave pubblica.\\
Vengono fornite, mediante il costrutto $\texttt{foreach}$, $\texttt{qS}$ copie dell'oracolo $\texttt{OS}$ le quali si occupano di restituire in output una firma del messaggio che gli viene dato in input.
La firma di un messaggio $\texttt{m}$, data una chiave privata $\texttt{sk}$ mediante la funzione $\texttt{f}$, viene effettuata restituendo il valore $\texttt{invf(sk, m)}$.\\ 
Infine viene fornito un oracolo $\texttt{OT}$ che si occupa di verificare se la firma $\texttt{s}$ \`e valida per il messaggio $\texttt{m1}$. \\
In particolare se $\texttt{hash(m1)}$ $\neq$ $\texttt{f(pk, s)}$ allora la firma non \`e valida per il messaggio. Se invece $\texttt{hash(m1) = f(pk, s)}$,
l'oracolo si occupa di verificare se, per il messaggio $\texttt{m1}$, \`e stata mai rilasciata una firma dall'oracolo $\texttt{OS}$. In caso affermativo il processo termina, altrimenti significa che 
l'attaccante, \`e stato in grado di forgiare una firma valida per il messaggio, e quindi \`e avvenuto l'evento \emph{forge}.\\
Notiamo come l'attaccante non sia modellato esplicitamente, infatti non possiamo fare nessuna assunzione sul comportamento di questo.
Possiamo immaginare un attaccante come un altro processo non meglio specificato messo in parallelo con questo game.\\ 
Per poter trasformare un game in un altro, CryptoVerif ha bisogno di alcune definizioni di primitive crittografiche da poter utilizzare.
\\
Le definizioni in CryptoVerif vengono fornite attraverso delle equivalenze che possono essere viste come regole di riscrittura 
delle distribuzioni di probabilit\`a delle variabili in gioco.
Queste regole di riscrittura di un generico elemento \emph{L} in un generico elemento \emph{R}, possono essere valide incondizionatamente, 
oppure possono valere a meno di una certa probabilit\`a.
Nel secondo caso la riscrittura di un termine \emph{L} nell'equivalente \emph{R}, comporta l'introduzione di una differenza non nulla fra i due games; di solito per\`o
questa differenza introdotta \`e rilevata dall'avversario solo con probabilit\`a trascurabile oppure con probabilit\`a trascurabilmente vicina a qualche costante come 
per esempio $\frac{1}{2}$.
\\ 
Prima di descrivere la seconda parte dell'input di CryptoVerif, \`e necessario fare una piccola digressione riguardo al concetto di funzione \emph{one-way}.
Intuitivamente una funzione $f$ \`e one-way se non pu\`o essere invertita facilmente; cio\`e se, dato $y=f(x)$, \`e arduo riuscire a trovare un $x'$ tale che $f(x')=y$. 
Si noti come non sia necessario, per invertire la funzione, trovare $x$ ma \`e sufficiente trovare un $x'$ qualsiasi tale che $f(x')=y$.
\\Possiamo ora dare la seguente:
\begin{definizione}[Funzione One-Way]
Una funzione $f: \{0,1\}^*\rightarrow \{0,1\}^*$ \`e one-way se e solo se $\forall x \in  \{0,1\}^* \hbox{,} \forall A \in PPT$:  $\lvert Pr[A(f(x)) \in f^{-1}(f(x))]\rvert$ \`e una funzione 
trascurabile.
\end{definizione}

\`E importante notare come la definizione valga per ogni $x$ del dominio; con questo si vuole sottolineare che invertire $f$ deve essere \emph{sempre} difficile e non per particolari $x$.
\`E importante affermare ci\`o perch\'e tutta la crittografia moderna \`e fondata sull'ipotesi che esistano le funzioni one-way.
Si parla di ipotesi perch\'e, sebbene la maggior parte degli informatici ne sia convinta, non \`e stata ancora dimostrata l'esistenza di funzioni di questo genere\footnote{Questo non toglie
che esistano funzioni che si avvicinino all'idea che abbiamo di funzioni one-way, per esempio SHA1, o MD5.}.
La dimostrazione dell'esistenza di funzioni one-way comporterebbe, tra l'altro, anche la risoluzione della famosa questione riguardo agli insiemi
$P$ e $NP$\footnote{$P$ \`e l'insieme dei problemi risolvibili, nel caso pessimo, in un numero di passi polinomiale nell'input. $NP$ invece, \`e l'insieme dei problemi per cui dato un certo valore, 
si pu\`o verificare in tempo polinomiale se questo \`e o meno soluzione del problema (ovvero \`e l'insieme dei problemi con certificazione polinomiale). 
Non \`e ancora noto se questi insiemi siano o meno lo stesso insieme.}.
Il fatto che però qualcuno un giorno possa dimostrare che $P \neq NP$ non dimostrerebbe affatto l'esistenza delle funzioni one-way. 
Infatti una funzione one-way deve, come prima sottolineato, essere non invertibile in modo efficiente, sempre e non solo nel \emph{caso pessimo}. \\ 
Siamo ora pronti per vedere come il concetto di funzione one-way venga modellato in CryptoVerif.
Si tratta di dare una definzione di one-wayness per mezzo di un'equivalenza fra games.\\La definizione \`e la seguente:
\newpage
\begin{verbatim}
equiv 
       foreach iK <= nK do r <-R seed; (
       Opk() := return(pkgen(r)) |
       foreach iF <= nF do x <-R D;
           (Oy() := return(f(pkgen(r), x)) |
            foreach i1 <= n1 do Oeq(x' : D) := return(x' = x) |
            Ox() := return(x)))
   
\end{verbatim}
\texttt{$\approx _{pow}$} 
\begin{verbatim}       
       foreach iK <= nK do r <-R seed; (
       Opk() := return(pkgen'(r)) |
       foreach iF <= nF do x <-R D;
          (Oy() := return(f'(pkgen'(r), x)) |
           foreach i1 <= n1 do Oeq(x':D) :=
                 if defined(k) then 
                     return(x' = x) 
                 else return(false) |
           Ox() := let k:bitstring = mark in return(x))).
 \end{verbatim}
Per ora, non \`e interessante per quale probabilit\`a questi games siano equivalenti, ecco perch\`e si \`e semplicemente indicato il valore della probabilit\`a con $pow$ senza specificare ulteriormente.
Questa equivalenza fra games cattura e definisce il concetto di funzione one-way. La funzione $\texttt{f}$ infatti, \`e one-way se e solo se vale l'equivalenza di cui sopra, 
e quindi il game a sinistra e quello a destra del simbolo \textbf{$\approx _{pow}$} sono indistinguibili.
Supponiamo infatti che la funzione $\texttt{f}$ non sia one-way, esister\`a dunque un avversario efficiente $A$ 
che pu\`o invertire $\texttt{f}$. $A$ sar\`a dunque in grado di distinguere i due membri dell'equivalenza $L \approx_{pow} R$. 
Questo perch\'e potendo invertire $\texttt{f}$, $A$ sar\`a in grado di osservare comportamenti diversi fra i game a seconda che $A$ chiami $\texttt{Oeq()}$ in $L$ o in $R$.
Procediamo con una sorta di esperimento mentale.\\ 
Supponiamo che $A$ chiami $\texttt{Oy()}$ ottenendo l'immagine di un valore mediante $\texttt{f}$, sia questa $y$; poich\'e $\texttt{f}$ non \`e one-way, 
$A$ inverte la funzione ottenendo un \verb!x'! tale che \verb!f(x')= y!.
Adesso $A$ non deve far altro che richiamare $\texttt{Oeq()}$ passando a questo come argomento \verb!x'!. Se $\texttt{Oeq()}$ \`e richiamato dal primo membro dell'equivalenza, 
allora $\texttt{Oeq()}$ ritorner\`a sempre true, mentre se appartiene al secondo ritorner\`a sempre false.\\
In questo modo $A$ osserva dei comportamenti diversi fra i due game, e quindi pu\`o distinguerli. 
Supponiamo, invece, che $\texttt{f}$ sia effettivamente one-way. Allora non esister\`a nessun attaccante efficiente che riesca ad invertire $\texttt{f}$.
L'unico modo che ha quindi un attaccante $A$ per invertire la funzione \`e chiamare $\texttt{Ox()}$ e ottenere cos\`i una preimmagine valida. 
Se però l'attaccante chiama $\texttt{Ox()}$ allora $L$ e $R$ sono effettivamente indistinguibili (a meno di una probabilit\`a trascurabile di cui parleremo dopo).
Notiamo infatti nella definizione dell'equivalenza che  $\texttt{Ox()}$\`e definito in maniera diversa in $L$ ed $R$.
In $L$, $\texttt{Ox()}$ si occupa semplicemente di ritornare il valore del dominio $\texttt{x}$, tale che $\texttt{f(x)=y}$. 
In $R$ invece, $\texttt{Ox()}$ prima di ritornare $\texttt{x}$, imposta al valore $\texttt{mark}$ la variabile $\texttt{k}$.
Ora, $\texttt{Oeq()}$ si comporter\`a in maniera diversa a seconda che sia richiamato da $L$ o da $R$.
Se infatti $\texttt{Oeq()}$ \`e chiamato da $L$, allora $\texttt{Oeq()}$ si proccuper\`a semplicemente di ritornare il valore booleano dell'espressione \verb!x'=x!.
Se invece,  $\texttt{Oeq()}$\`e chiamato da $L$ allora $\texttt{Oeq()}$ si comporter\`a in maniera differente a seconda che la variabile $\texttt{k}$ abbia o meno un valore 
(ovvero sia stata o meno definita da una precedente chiamata a $\texttt{Ox()}$). Se quindi $\texttt{k}$ \`e definita, allora $\texttt{Oeq()}$ si comporter\`a esattamente come si sarebbe comportato $\texttt{Oeq()}$  di $L$.
Se invece $\texttt{k}$ non \`e stata definita allora siginifica che l'attaccante non ha richiamato $\texttt{Ox()}$, quindi \`e lecito supporre che non sia riuscito ad invertire $\texttt{f}$ e quindi $\texttt{Oeq()}$ ritorna false.\\
\`E importante notare che l'attaccante avrebbe comunque la possibilit\`a di indovinare $\texttt{x}$ anche senza richiamare $\texttt{Ox()}$, ma questa \`e una probabilit\`a trascurabile per definizione di one-wayness. 
Di questa probabilit\`a viene comunque tenuto conto nell'equivalenza. L'equivalenza infatti, vale a meno di una certa probabilit\`a $pow$ (trascurabile in questo caso).
In questo modo i due games, sono effettivamente indistinguibili, perch\'e non presentano differenze di comportamento che $A$ possa notare, e quindi ai suoi occhi sono indistinguibili.
Quindi $L$ e $R$ sono indistinguibili \emph{se e solo se} $\texttt{f}$ \`e one-way e di conseguenza la precedente equivalenza \`e una definizione ben posta di funzione one-way.
Un'ulteriore definizione che viene fornita al CryptoVerif \`e quella di funzione hash. Questa definizione viene fornita al tool attraverso il seguente codice:
\begin{verbatim}
fun hash(hashinput):hashoutput.
equiv foreach iH <= nH do 
        OH(x:hashinput) := return(hash(x)) [all]
        <=(0)=>
      foreach iH <= nH do 
        OH(x:hashinput) :=
            find[unique] u <= nH suchthat defined(x[u],r[u]) && 
                    otheruses(r[u]) && x= x[u] then 
                        return(r[u]) 
            else 
               r <-R hashoutput; 
               return(r).
\end{verbatim}

La funzione hash \`e intesa implementata nel modello dell'oracolo random: se la funzione non \`e mai stata richiamata su un particolare valore $x_0$ allora viene restituito un valore casuale, 
altrimenti viene restituito lo stesso valore che era stato dato in output precedentemente. Questo viene fatto salvando il valore restituito per un particolare input in un array e poi,
al momento della chiamata, si effettua un lookup nell'array.
Infine abbiamo una semplice teoria equazionale per descrivere alcune propriet\`a delle funzioni in gioco.
Per esempio:
\begin{verbatim}
forall r:seed, x:D, x':D; (x' = invf(skgen(r),x)) = (f(pkgen(r),x') = x).
forall r:seed, x:D; f(pkgen(r), invf(skgen(r), x)) = x.
forall r:seed, x:D; invf(skgen(r), f(pkgen(r), x)) = x.
\end{verbatim}
Le precedenti regole servono a definire $\texttt{invf}$ come funzione inversa di $\texttt{f}$ e viceversa. Mentre le seguenti:
\begin{verbatim}
forall k:skey, x:D, x':D; (invf(k,x) = invf(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f(k,x) = f(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f'(k,x) = f'(k,x')) = (x = x).
\end{verbatim}\\
modellano l'iniettivit\`a delle funzioni $\texttt{invf}$, \verb!f'!, $\texttt{f}$\footnote{Non serve ai fini della dimostrazione modellare l'iniettivit\`a della funzione invf{'}}.
Nell'appendice A si pu\`o trovare l'input completo, mentre in \cite{BlanchetPointchevalCrypto06} possiamo trovare una spiegazione delle fasi 
pi\`u importanti dell'output di CryptoVerif e infine in \cite{fdhall} troviamo l'ouput completo di CryptoVerif sull'input descritto precedentemente.








\chapter{Risultati Raggiunti}
Scopo principale di questo lavoro \`e la dimostrazione mediante CryptoVerif di un risultato classico della crittografia computazionale.
Dopo un'attenta analisi si \`e giunti alla conclusione che, a causa dell'insufficiente sistema di tipi di CryptoVerif, non sarebbe stato
possibile mediante questo dimostrare il risultato nella sua generalit\`a; ecco quindi che si \`e scelto di utilizzare il tool
per dimostrare una caso particolare del teorema.
\section{Teorema}
Il risultato nella sua generalit\`a \`e il seguente teorema:
\begin{teorema}
Se esiste un generatore pseudocasuale $G^{'}:$ $\{0, 1\}^n \rightarrow \{0, 1\}^{n+1}$ con fattore 
d'espansione $l^{'}(n)=n+1$ allora per ogni polinomio $p(n)$ (tale che $\forall n$ $p(n)>n$)
esiste un generatore pseudocasuale $G$ con coefficiente d'espansione $l(n)=p(n)$.
\end{teorema}

Si pu\`o trovare una dimostrazione \emph{classica} di questo teorema in \cite{1206501}. La dimostrazione classica procede....

Si \`e invece provato il risultato con CryptoVerif per un numero $p(n)$ che \`e una costante. In particolare mediante CryptoVerif si \`e provato
che:
\begin{teorema}
Se esiste un generatore pseudocasuale $G^{'}:$ $\{0, 1\}^n \rightarrow \{0, 1\}^{n+1}$ 
con fattore d'espansione $l^{'}(n)=n+1$ allora per ogni costante $k$ esiste un generatore 
pseudocasuale $G$ con coefficiente d'espansione $l(n)=n+k$
\end{teorema}



\newpage
\section{L'input}
Il codice che verr\`a descritto permette a CryptoVerif di dimostrare che se si ha a disposizione un generatore pseudorandom con fattore
di espansione $n+1$ allora si pu\`o avere un generatore pseudorandom con fattore di espansione $n+3$.
L'input che \`e stato fornito a CryptoVerif inizia con le seguenti dichiarazioni:
\begin{verbatim}
  1 type nbits 	 [fixed].     
  2 type np1bits [fixed].   
  3 type np2bits [fixed].   
  4 type np3bits [fixed]. 
\end{verbatim}
Queste linee di codice servono per dichiarare dei tipi. Alla linea 1 dichiariamo il tipo delle stringhe di lunghezza n, ovvero
definiamo il tipo \emph{nbits}. Questo tipo rappresenter\`a l'insieme $\{0, 1\}^n$. Alla linea 2 invece viene dichiarato un tipo
per rappresentare le stringhe appartenenti all'insieme $\{0, 1\}^{n+1}$, mentre nelle righe 3 e 4 lo stesso viene fatto per le stringhe
casuali appartenenti agli insiemi $\{0, 1\}^{n+2}$, e $\{0, 1\}^{n+3}$. Si noti come ogni tipo sia dichiarato con il modificatore $fixed$.
Infatti CryptoVerif permette una scelta casuale all'interno di un dominio se e solo se questo \`e dichiarato come fixed.
Con la linea di codice seguente:
\begin{verbatim}
5 param n1.
\end{verbatim}
Si dichiara un parametro $n1$. Questo parametro assumer\`a valori polinomiali nel parametro di sicurezza. 
Sar\`a utilizzato principalmente per fornire al distinguitore un numero polinomiale di oracoli con cui interagire.
Quelle che seguono sono delle dichiarazioni di simboli di funzioni con i relativi tipi di input e di output.
\begin{verbatim}  
7 fun concatnp1(np1bits,bool):np2bits.
8 fun concatnp2(np1bits,bool, bool):np3bits.
\end{verbatim}
In particolare la prima funzione prende in input come argomenti una stringa di lunghezza $n+1$ e un bit quest'ultimo rappresentato attraverso
un valore booleano. L'output sar\`a una stringa di lunghezza $n+2$.
La seconda funzione invece prende in input una stringa di $n+1$ bits e due bits, anche questi rappresentati mediante valori booleani.
Il risultato di questa funzione sar\`a una stringa di lunghezza $n+3$. Come si pu\`o intuire dai nomi delle funzioni, queste rappresentano
la concatenazione di stringhe di lunghezza $n+1$ con uno e due bits rispettimavamente.
Mediante le seguenti equivalenze non facciamo altro che implementare le funzioni dichiarate prima.
Per esempio la funzione concatnp1 viene descritta mediante un'equivalenza che rappresenta il seguente asserto:
la concatenazione di una stringa casuale di $n+1$ bits con un bit casuale \`e una stringa casuale di
$n+2$ bits. 
\begin{verbatim}
 10 equiv
 11       foreach i1<=n1 do
 12             r <-R np1bits;
 13             b <-R bool;
 14             OGet():=return (concatnp1(r,b))
 15       <=(0)=>
 16      foreach i1 <=n1 do
 17             w <-R np2bits;
 18             OGet():=return(w).
\end{verbatim} 
Una definizione simile \`e stata data per la funzione $concatpn2$:
\begin{verbatim}
 20 equiv
 21     foreach i1<=n1 do
 22             r<-R np1bits;
 23             b'<-R bool;
 24             b''<-R bool;
 25             OGet():=return(concatnp2(r, b'', b'))
 26     <=(0)=>
 27     foreach i1<=n1 do
 28             w<-R np3bits;
 29             OGet():=return(w).
\end{verbatim}
Infatti concatenare due bits casuali ad una stringa casuale di lunghezza $n+1$ \`e equivalente a scegliere in maniera casuale una stringa
dall'insieme $\{0, 1\}^{n+3}$.
 31 fun getn(np1bits):nbits.
 32 fun getlast(np1bits):bool.
 33 equiv
 34        foreach i1<=n1 do
 35              r <-R np1bits;(
 36              OGetn():=return (getn(r)) |
 37              OGetlast():=return (getlast(r)))
 38        <=(0)=>
 39       foreach i1 <=n1 do
 40               (
 41               OGetn():= w <-R nbits;return(w) |
 42               OGetlast():=wl <-R bool;return(wl)
 43               ).
 44 fun getn1(np2bits):nbits.
 45 fun getlast1(np2bits):bool.
 46 equiv
 47       foreach i1<=n1 do
 48             r <-R np2bits;(
 49             OGetn():=return (getn1(r)) |
 50             OGetlast():=return (getlast1(r)))
 51       <=(0)=>
 52      foreach i1 <=n1 do
 53              (
 54              OGetn():= w <-R nbits;return(w) |
 55              OGetlast():=wl <-R bool;return(wl)
 56              ).
 57 
 58 fun G'(nbits): np1bits.
 59 equiv
 60     foreach i1<=n1 do
 61                 r <-R nbits;
 62                 OGet():=return (G'(r))
 63       <=(0)=> (* To define *)
 64      foreach i1 <=n1 do
 65                 w <-R np1bits;
 66                 OGet():=return(w).
 67 
 68 query secret1 w3.
 69 
 70 
 71 process
 72         O():=
 73              r<-R nbits;
 74              let x' = G'(r) in
 75              let y' = getn(x') in
 76              let b' = getlast(x') in
 77              let x''=G'(y') in
 78              let y''=getn(x'') in
 79          	 let b''=getlast(x'') in
 80              w3:np3bits <-concatnp2(G'(y''), b'', b');
 81 		 return
\section{L'output}
L'output di CryptoVerif \`e il seguente:
\begin{verbatim}
Doing expand if, let, find... No change.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... No change.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... Done.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Failed.
Trying equivalence
equiv foreach i1_7 <= n1 do r <-R np2bits; (
  OGetn() := return(getn1(r)) |
  OGetlast() := return(getlast1(r)))
<=(0)=>
      foreach i1_8 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Failed.
Trying equivalence
equiv foreach i1_5 <= n1 do r <-R np1bits; (
  OGetn() := return(getn(r)) |
  OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_6 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... Done.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... Done.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Failed.
Trying equivalence
equiv foreach i1_7 <= n1 do r <-R np2bits; (
  OGetn() := return(getn1(r)) |
  OGetlast() := return(getlast1(r)))
<=(0)=>
      foreach i1_8 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Failed.
Trying equivalence
equiv foreach i1_5 <= n1 do r <-R np1bits; (
  OGetn() := return(getn(r)) |
  OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_6 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... Done.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... No change.
Trying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
... Failed.
Trying equivalence
equiv foreach i1_7 <= n1 do r <-R np2bits; (
  OGetn() := return(getn1(r)) |
  OGetlast() := return(getlast1(r)))
<=(0)=>
      foreach i1_8 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Failed.
Trying equivalence
equiv foreach i1_5 <= n1 do r <-R np1bits; (
  OGetn() := return(getn(r)) |
  OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_6 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
... Failed.
Trying equivalence
equiv foreach i1_3 <= n1 do r <-R np1bits; b' <-R bool; b'' <-R bool; OGet() := return(concatnp2(r, b'', b'))
<=(0)=>
      foreach i1_4 <= n1 do w <-R np3bits; OGet() := return(w)
... Succeeded.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of useless... No change.
Proved one-session secrecy of w3
===================== Proof starts =======================
Initial state
Game 1 is
O() :=
r <-R nbits;
x': np1bits <- G'(r);
y': nbits <- getn(x');
b': bool <- getlast(x');
x'': np1bits <- G'(y');
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', b');
return()


Applying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
 yields

Game 2 is
O() :=
w_11 <-R np1bits;
x': np1bits <- w_11;
y': nbits <- getn(x');
b': bool <- getlast(x');
x'': np1bits <- G'(y');
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', b');
return()


Applying remove assignments of useless yields

Game 3 is
O() :=
w_11 <-R np1bits;
y': nbits <- getn(w_11);
b': bool <- getlast(w_11);
x'': np1bits <- G'(y');
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', b');
return()


Applying equivalence
equiv foreach i1_5 <= n1 do r <-R np1bits; (
  OGetn() := return(getn(r)) |
  OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_6 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
 yields

Game 4 is
O() :=
wl_13 <-R bool;
w_12 <-R nbits;
y': nbits <- w_12;
b': bool <- wl_13;
x'': np1bits <- G'(y');
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', b');
return()


Applying remove assignments of useless yields

Game 5 is
O() :=
wl_13 <-R bool;
w_12 <-R nbits;
x'': np1bits <- G'(w_12);
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', wl_13);
return()


Applying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
 yields

Game 6 is
O() :=
wl_13 <-R bool;
w_14 <-R np1bits;
x'': np1bits <- w_14;
y'': nbits <- getn(x'');
b'': bool <- getlast(x'');
w3: np3bits <- concatnp2(G'(y''), b'', wl_13);
return()


Applying remove assignments of useless yields

Game 7 is
O() :=
wl_13 <-R bool;
w_14 <-R np1bits;
y'': nbits <- getn(w_14);
b'': bool <- getlast(w_14);
w3: np3bits <- concatnp2(G'(y''), b'', wl_13);
return()


Applying equivalence
equiv foreach i1_5 <= n1 do r <-R np1bits; (
  OGetn() := return(getn(r)) |
  OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_6 <= n1 do w <-R nbits; wl <-R bool; (
  OGetn() := return(w) |
  OGetlast() := return(wl))
 yields

Game 8 is
O() :=
wl_13 <-R bool;
wl_16 <-R bool;
w_15 <-R nbits;
y'': nbits <- w_15;
b'': bool <- wl_16;
w3: np3bits <- concatnp2(G'(y''), b'', wl_13);
return()


Applying remove assignments of useless yields

Game 9 is
O() :=
wl_13 <-R bool;
wl_16 <-R bool;
w_15 <-R nbits;
w3: np3bits <- concatnp2(G'(w_15), wl_16, wl_13);
return()


Applying equivalence
equiv foreach i1_9 <= n1 do r <-R nbits; OGet() := return(G'(r))
<=(0)=>
      foreach i1_10 <= n1 do w <-R np1bits; OGet() := return(w)
 yields

Game 10 is
O() :=
wl_13 <-R bool;
wl_16 <-R bool;
w_17 <-R np1bits;
w3: np3bits <- concatnp2(w_17, wl_16, wl_13);
return()


Applying equivalence
equiv foreach i1_3 <= n1 do r <-R np1bits; b' <-R bool; b'' <-R bool; OGet() := return(concatnp2(r, b'', b'))
<=(0)=>
      foreach i1_4 <= n1 do w <-R np3bits; OGet() := return(w)
 yields

Game 11 is
O() :=
w_18 <-R np3bits;
w3: np3bits <- w_18;
return()


RESULT Proved one-session secrecy of w3
All queries proved.
\end{verbatim}

\chapter{Conclusioni}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\bibliographystyle{alpha}	
\bibliography{myrefs}		
\end{document}          
