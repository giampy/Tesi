\documentclass[a4paper,openright,twoside,12pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{amssymb}
\author{Gian Pietro Farina}


\newtheorem{definizione}{Definizione}[chapter]
\pagenumbering{arabic}
\begin{document}
\chapter*{Introduzione}
\rhead[\fancyplain{}{\bfseries INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\addcontentsline{toc}{chapter}{Introduzione}
\clearpage{\pagestyle{empty}\cleardoublepage}
%Nel capitolo intoduttivo si introdurranno il modello formale Vs quello computazionale,
%il concetto di sicurezza perfetta e quella computazionale per poi riprendere quest'ultima nel
%capitolo 1
\chapter{Il Modello Computazionale}
\section{L'avversario}
Il tipico avversario con cui si ha a che fare quando si studiano cifrari o protocolli crittografici nel modello computazionale,
è un avversario con risorse di calcolo \emph{limitate}. Limitate nel senso che si sceglie di porre un limite alla potenza dell'avversario.
Questo significa che: non avremo a che fare con un avversario che ha una potenza computazionale infinita o un tempo illimitato a disposizione.
Sebbene siano stati ideati cifrari sicuri anche rispetto ad avversari non limitati\footnote{one-time pad ne \`e un esempio lampante.}, questi soffrono di vari difetti: come per esempio
il fatto che \`e necessario che la chiave sia lunga quanto il messaggio e che sia utilizzabile una sola volta.
Per rappresentare in modo formale un avversario con risorse di calcolo limitate, lo si può pensare come un algoritmo appartenente ad una 
particolare classe di complessit\`a computazionale\footnote{un avversario \`e alla fine dei conti una macchina di Turing che esegue un algoritmo.}. 
Da sempre si considerano efficienti gli algoritmi che terminano in un numero di passi polinomiale nella lunghezza dell'input, mentre si considerano inefficienti 
quelli che hanno una complessit\`a computazionale maggiore. Pu\`o sembrare quindi naturale immaginare gli avversari come degli algoritmi che terminano in un numero polinomiale di passi
rispetto alla lunghezza dell'input.
Non bisogna per\`o dimenticare che un avversario può sempre \emph{indovinare} il segreto che cerchiamo di nascondere, o che cifriamo. 
Per esempio: se il segreto che si cerca di nascondere ha una lunghezza di $n$ bit, l'avversario può sempre
lanciare una moneta $n$ volte e associare via via la testa della moneta al valore 1 e la croce al valore 0.
La probabilit\`a che l'avversario ottenga una stringa uguale al segreto \`e ovviamente di $\frac{1}{2^n}$. 
Questa probabilit\`a tende a 0 in modo esponenziale al crescere della lunghezza del segreto. Ma per valori finiti di $n$ questa probabilit\`a non sar\`a mai 0.
\`E quindi pi\`u realistico cercare di rappresentare l'avversario come un'algoritmo che oltre a terminare in tempo polinomiale\footnote{nella lunghezza dell'input}, abbia
anche la possibilit\`a di effettuare scelte random.
Ecco quindi che il nostro tipico avversario \`e un algoritmo Polinomiale Probabilistico.
\`E inoltre giustificato cercare di rendere sicuri\footnote{In qualsiasi modo si possa intendere il concetto di sicurezza. 
Vedremo che in seguito si daranno delle definizioni rigorose di questo concetto.} gli schemi crittografici, rispetto principalmente, a questo tipo di avversario.
Con questa scelta si cerca di rispettare il pi\`u possibile un famoso principio di Kerckhoffs\footnote{Auguste Kerckhoffs (19 Gennaio 1835 – 9 Agosto 1903) 
fu un linguista Olandese e un famoso crittografo} che afferma: 
\begin{quotation}
\em
Un cifrario deve essere, se non matematicamente, almeno praticamente indecifrabile.
\end{quotation}
Non \`e quindi necessario dimostrare che un particolare schema crittografico sia inviolabile, ma basta dimostrare che:
\begin{itemize}
 \item si pu\`o violare con scarsissima probabilit\`a in tempi ragionevoli oppure
 \item lo si pu\`o violare con alta probabilit\`a solo in tempi non ragionevoli
\end{itemize}
In crittografia il concetto di \emph{scarsa probabilit\`a} viene formalizzato attraverso la nozione di funzione trascurabile.
\begin{definizione}{Funzione Trascurabile (negligible).}
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$. Si dice che $\mu$ \`e trascurabile se e solo se per ogni polinomio $p$ esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) < \frac{1}{p(n)}$.  
\end{definizione}
Un'altra definizione utile \`e la seguente:
\begin{definizione}{Funzione Notevole (noticeble).}
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R}$. Si dice che $\mu$ \`e notevole se e solo se esiste un polinomio $p$ esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) < \frac{1}{p(n)}$.  
\end{definizione}
Per esempio la funzione $2^{-\sqrt{n}}$ \`e una funzione trascurabile mentre per esempio la funzione $frac{1}{x^2}$ non lo \`e. Ovviamente esistono anche funzioni che non sono n\'e trascurabili 
ne


\section{Indistinguibilit\`a Computazionale}
\section{Dimostrazioni Basate su Games}
\section{Pseudocasualit1`a}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\end{document}          
