\documentclass[a4paper,openright,twoside,12pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs 
\usepackage{float}
\usepackage{setspace}
\usepackage[T1]{fontenc}
\author{Gian Pietro Farina}
\hyphenation{va-li-di-t\`a pro-ba-bi-li-t\`a ge-ne-ra-le se-con-do e-sem-pio na-tu-ra-le 
de-ter-mi-ni-sti-ci quo-ti-dia-na e-si-ste li-mi-ta-te li-mi-ta-ti e-qui-va-len-ti ov-via-men-te 
pseudo-ca-sua-le sem-bre-reb-be mo-di-fi-che e-qui-va-len-za ge-ne-ra-to-re po-ter va-lo-ri de-si-de-ra-no
d'e-qui-va-len-za Que-sta}
\floatstyle{boxed} 
\restylefloat{figure}
\newtheorem{definizione}{Definizione}[chapter]
\newtheorem{proposizione}{Proposizione}[chapter]
\newtheorem{teorema}{Teorema}[chapter]
\pagenumbering{arabic}
\pagestyle{fancy}
% i comandi seguenti impediscono la scrittura in maiuscolo
% dei nomi dei capitoli e dei paragrafi nelle intestazioni
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
            % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
   \fancyhead{} % ignora, nello stile plain, le intestazioni
   \renewcommand{\headrulewidth}{0pt} % e la linea
}

\begin{document}
\chapter*{} 
\thispagestyle{empty} 
\addtocounter{page}{-1} 
\tableofcontents
\chapter*{Introduzione}
\chaptermark{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}
\section*{La Crittografia Moderna}
Da quando, verso la fine del XX° secolo, la crittografia ha cessato di essere un'arte per assurgere al rango di scienza, 
si \`e proposta, innanzitutto, di fornire definizioni rigorose dei concetti con cui aveva a che fare (e.g. \emph{segretezza}) per poi apportare prove dei propri asserti basandosi 
su argomentazioni di carattere logico-matematico, ovvero di dimostrazioni. \\ Infatti, si pu\`o affermare che mentre prima,
con la crittografia classica si costruivano dei cifrari crittografici \emph{ad-hoc} che sembravano sicuri in una particolare situazione, ma che successivamente
non si dimostravano tali, con la crittografia moderna si ha un atteggiamento profondamente diverso: si parte da delle definizioni e poi
si \emph{dimostra} che gli schemi costruiti rispettano queste definizioni, dando quindi dei risultati pi\`u oggettivi e universali.
Prima dell'avvento della crittografia moderna la costruzione di un cifrario \emph{valido} si basava soprattutto sulla creativit\`a 
dei crittografi. Oggigiorno, prima di provare che un cifrario sia valido, bisogna dare una definizione di cifrario valido, 
inoltre il fatto
che il cifrario rispetti questa definizione deve essere provato con una dimostrazione.
In passato la crittografia aveva come ambiente naturale quello militare e come scopo ultimo la segretezza di un messaggio.
Oggi la crittografia non \`e pi\`u utilizzata solo in ambiente militare. I suoi campi di utilizzo si estendono a molti aspetti 
della vita quotidiana: e-mail, connessioni sicure codici bancari ecc, ecc\dots
Questo fatto ha comportato anche un ampliamento dei possibili scopi della crittografia. Se infatti, un tempo, l'unico obiettivo che si proponeva la crittografia era quello di garantire
la segretezza di un messaggio oggigiorno deve poter fornire molte altre garanzie fra le quali: autenticazione e integrit\`a dei messaggi scambiati. Ecco, quindi, che la nascita di queste esigenze
ha portato allo studio di schemi crittografici come per esempio \emph{message authentication codes} (meglio noti come MAC) oppure schemi crittografici asimmetrici.
Quando si parla di segretezza, \`e importante, come gi\`a accennato, dare prima una definizione di cosa si intenda con questo termine.
Se, per esempio, si intende che nessun attaccante possa mai venire a conoscenza della chiave, 
allora si ottiene qualcosa che non \`e quello che si vorrebbe. La segretezza, infatti, riguarda un messaggio:
la chiave \`e solo un mezzo che si utilizza per ottenere questo scopo. 
Se invece si intende che un attaccante non riesca mai a decifrare il messaggio si \`e alla ricerca di una chimera. Come si vedr\`a nel proseguo infatti, 
nella maggior parte dei casi, posto che si abbia sufficiente tempo 
a disposizione, si pu\`o sempre riuscire a decifrare con \emph{certezza} il messaggio; inoltre esiste sempre la possibilit\`a che un attaccante riesca ad indovinare il messaggio
semplicemente \emph{tirando ad indovinare}. Se, infine, si intende che ogni attaccante con determinate caratteristiche riesca difficilmente ad indovinare il messaggio cifrato, allora esiste la 
possibilit\`a di ottenere schemi che rispettino questo tipo di definizione. Ovviamente \`e necessario prima formalizzare in modo 
corretto il concetto di \emph{difficolt\`a}.


Sebbene in alcuni casi sia possibile (ed \`e stato fatto, i.e ~\cite{Shannon}) provare \emph{incondizionatamente} dei risultati, la maggior parte dei teoremi, nel campo 
della crittografia moderna, si basano su assunzioni che non sono ancora certe, ma che sono comunque ben formalizzate e inequivocabilmente descritte.\\La pi\`u importante \`e sicuramente
l'ipotesi dell'esistenza di funzioni \emph{one-way}, le quali possono essere viste come funzioni \emph{facilmente} calcolabili
 ma \emph{difficilmente} invertibili\footnote{Si dar\`a pi\`u avanti una definizione rigorosa.}. 
Tale ipotesi \`e alla base di tutta la crittografia moderna. Se infatti, un giorno questa ipotesi venisse confutata, probabilmente
tutta la teoria riguardante la crittografia moderna perderebbe d'interesse. Il fatto che per\`o le dimostrazioni in questo campo possano perdere d'interesse
non significa che queste siano errate. Infatti tutte le prove che sono basate su assunzioni non verificate sono sempre e comunque valide, sia che le assunzioni fatte vengano dimostrate,
sia che vengano confutate. Ogni dimostrazione \`e infatti del tipo: \emph{Se X allora Y} dove \emph{X} contiene un quantificatore esistenziale (e.g. se esiste una funzione one-way allora esiste un generatore pseudocasuale con fattore
d'espansione polinomiale). Quindi, semplicemente, nel caso in cui le assunzioni dovessero essere confutate si renderebbero poco interessanti le dimostrazioni\footnote{\`E ovvio infatti, che partendo da ipotesi false si possa
dimostrare qualsiasi cosa.}.
\`E per\`o giusto dire che le assunzioni che vengono fatte sono largamente ritenute vere; questo anche  grazie al fatto che alcune di esse si possono dedurre da altre ipotesi, 
anche queste ampiamente accettate sebbene non dimostrate.\\Lo studio di una congettura, infatti, pu\`o fornire evidenti prove della sua validit\`a mostrando che essa \`e la tesi di un teorema che assume come ipotesi
un'altra congettura largamente ritenuta valida.


Quando si parla di crittografia, bisogna distinguere fra primitive crittografiche e protocolli crittografici.
Una primitiva crittografica pu\`o essere vista come un algoritmo crittografico con lo scopo 
di prendere un messaggio e, mediante una chiave, ottenere un messaggio cifrato. 
I protocolli sono, invece, un insieme di azioni che si basano su delle primitive crittografiche al fine di fornire
servizi pi\`u vasti rispetto alla semplice cifratura (e.g. la condivisione di una chiave di sessione a partire
da un'altra chiave segreta condivisa a priori fra due parti).

\section*{I Due Modelli}
%\section{Il Due Modelli}
Da quando la crittografia si \`e guadagnata una validit\`a scientifica, sono nati almeno due modi profondamente
 diversi fra loro di studiare i protocolli crittografici.\\Nel modello \emph{formale}, le operazioni crittografiche sono rappresentate da 
espressioni simboliche, formali appunto.
Nel modello \emph{computazionale}, le operazioni crittografiche sono viste come funzioni su stringhe di bit che hanno una semantica probabilistica.
Il primo modello, chiamato anche modello di \emph{Dolev-Yao} dal nome degli autori dei primi articoli in cui venne formalizzato,
\`e stato ampiamente trattato in \cite{AbadiG99, BurrowsAN90, Kemmerer87, Paulson98}. 
Il secondo modello trova le basi in lavori di altrettanto illustri studiosi come per esempio Goldwasser e Micali in \cite{GoldwasserM84}.\\
Il modello formale pu\`o contare su un vastissimo insieme di conoscenze teoriche derivanti da altri rami dell'informatica, in particolare: la teoria dei linguaggi formali e della logica;
anche per questo il modello formale \`e stato sicuramente trattato in modo pi\`u approfondito, almeno fino ad ora. 
Nel modello formale i protocolli crittografici sono spesso rappresentati come programmi, o meglio, come processi elaborati
in un particolare calcolo di processi. O ancora, nel modello formale, le 
primitive crittografiche sono trattate spesso come dei semplici simboli funzionali. 
In questo modo \`e possibile applicare molta della teoria gi\`a esistente, 
che riguarda la verifica formale della correttezza dei programmi, al caso particolare dei protocolli crittografici.
Per fare questo si considerano particolari relazioni d'equivalenza (per esempio l'equivalenza per test, o la 
bisimulazione \cite{AbadiG99}) fra processi e si cerca di dimostrare che un particolare protocollo \`e equivalente ad un programma considerato sicuro.


Tutto ci\`o ha fatto s\`i che lo stato dell'arte veda molti pi\`u tool di
verifica automatica che lavorano nel modello formale rispetto a tool che lavorano nel modello computazionale. 
Uno tra i pi\`u famosi tool che lavora nel modello formale \`e sicuramente \emph{ProVerif}. 
ProVerif \`e un verificatore automatico di protocolli crittografici che lavora nel modello formale e permette di provare
propriet\`a quali: segretezza, segretezza forte e autenticazione. \`E stato gi\`a applicato a \emph{Plutus File System} e 
al protocollo $JFK$ e a molti altri protocolli\footnote{Per informazioni pi\`u dettagliate su questo tool si visiti il seguente sito web: 
\url{http://www.proverif.ens.fr/}}.
I sostenitori del modello formale affermano che \`e molto conveniente ignorare i dettagli di una funzione crittografica 
e lavorare con una descrizione 
di pi\`u alto livello di questa, che non includa dettagli riguardanti la funzione. 
I sostenitori del modello crittografico computazionale, invece, affermano che la visione
del modello formale non \`e molto realistica e che le funzioni crittografiche non debbano essere viste come espressioni 
formali, ma come algoritmi deterministici e/o probabilistici. Una delle pi\`u grandi critiche mosse dai sostenitori del modello
computazionale a quelli del modello formale \`e che trattando le primitive crittografiche come dei simboli impenetrabili (appunto, come delle espressioni formali), 
assumono, implicitamente, che siano corrette e inviolabili, ma questo non \`e
del tutto esatto. Per esempio, nel modello formale, un messaggio cifrato utilizzato in un protocollo,  
potrebbe essere rappresentato dall'espressione $\{M\}_k$ con $k$ appartenente allo spazio delle chiavi
e $M$ allo spazio dei messaggi. Un \emph{qualsiasi}\footnote{Qulsiasi capacit\`a di calcolo esso abbia.} 
attaccante che intercetta il messaggio $\{M\}_k$ non pu\`o derivare $M$ a meno
che non abbia intercettato anche $k$. Nel modello computazionale invece, si considera anche il fatto
che $M$, $k$ come anche $\{M\}_k$ non sono altro che sequenze finite di bit e che quindi esiste sempre la possibilit\`a
che un attaccante riesca a decifrare il messaggio, anche solo per caso. Inoltre, una differenza importante che si ha, \`e che mentre nel modello
formale non si considera la potenza di calcolo di un attaccante che quindi pu\`o anche essere infinita, nel modello computazionale
gli attaccanti considerati sono tutti e soli quelli che appartengono a una determinata classe di complessit\`a computazionale.
Come si vede, nel modello computazionale entrano in gioco altre branche dell'informatica e della matematica come per esempio
la teoria della complessit\`a computazionale e la teoria della statistica e delle probabilit\`a.
Il modello formale ha comunque molti vantaggi come quello precedentemente accennato che riguarda la semplicit\`a 
con cui vengono costruiti strumenti automatici per la verifica di protocolli in questo modello.
Sembrerebbe quindi, che esista un divario molto ampio fra i due modelli. In effetti cos\`i \`e, ma non sono mancati i tentativi di unificare le due teorie, o comunque di cercare una linea
di collegamento che le congiunga.
In \cite{DBLP:journals/joc/AbadiR07}, per esempio, gli autori cercano, per la prima volta, di porre le basi per iniziare a collegare questi due modelli.
In particolare il principale risultato di questo lavoro afferma che se due espressioni nel modello formale sono equivalenti, una volta dotate di un'opportuna semantica probabilistica,
possono essere mappate in \emph{ensemble} computazionalmente indistinguibili; quindi, sotto forti, ma accettabili ipotesi\footnote{Un'importante ipotesi usata nella dimostrazione del risultato in questione
\`e che non devono esserci cicli crittografici, ovvero si considerano solo schemi crittografici in cui una chiave $k$, non \`e mai \emph{cifrata} attraverso $k$ stessa.}, 
l'equivalenza formale implica l'indistinguibilit\`a computazionale.
\`E quindi lecito affermare che un attaccante per il modello computazionale non \`e pi\`u potente di un attaccante nel modello formale. Questo risultato ha dato un'ulteriore spinta
ai sostenitori del modello formale che potevano cos\`i dimostrare risultati, con tutti i benefici che il modello formale comportava, 
e estenderli poi al modello computazionale senza troppi problemi.
Un'altra strada invece, \`e quella che prevede di lavorare direttamente nel modello computazionale senza preoccuparsi di rispettare le forti ipotesi che erano 
state usate per dimostrare il risultato raggiunto in \cite{DBLP:journals/joc/AbadiR07}.
Una tecnica molto utilizzata per provare dei risultati nell'ambito della crittografia computazionale, 
\`e la cosidetta \emph{tecnica per riduzione}. 
Le dimostrazioni basate su questa tecnica consistono nel cercare di ridurre un problema al problema crittografico in esame. 
Si cerca cio\`e di utilizzare una soluzione che risolva un problema crittografico
per risolvere un altro problema. Quindi un algortimo che risolve il problema crittografico diventa
una parte dell'algoritmo che risolve un altro problema.
Nella maggior parte dei casi si cerca di ridurre dei problemi che si sa essere \emph{difficili}. 
Supponiamo di sapere per certo che il problema $T$ \`e difficile. 
Supponiamo inoltre che si voglia dimostrare che lo schema crittografico $S$
sia sicuro. Si faccia ora l'assurda assunzione che il problema $S$ sia facilmente risolvibile, ovvero facilmente violabile. 
Se ora si \`e in grado di ridurre facilmente il problema $T$ al problema $S$, si ha che anche il problema $T$ \`e facilmente risolvibile.
Negando un'ipotesi iniziale si \`e quindi giunti ad una contraddizione che prova che $S$ \`e in realt\`a sicuro.
Si noti che fino a questo punto non si \`e data, in questo contesto, una definizione degli aggettivi $facile$ e $difficile$ e degli avverbi che ne derivano; 
questo \`e stato fatto per non rendere pesante la lettura di questa breve introduzione, pi\`u avanti per\`o, si daranno definizioni
di tutti i termini utilizzati.
Altre tecniche sfruttate nel mondo della crittografia computazionale sono la tecnica ibrida, spesso usata
per provare che due diverse distribuzioni statistiche sono in realt\`a indistinguibili, e la tecnica delle \emph{sequenze di giochi} di cui parleremo
in modo pi\`u approfondito pi\`u avanti.
\section*{Una visione d'insieme}
Nel capitolo successivo ci si propone innanzitutto di descrivere a grandi linee il modello computazionale, 
in modo che si possa leggere il secondo capitolo e comprendere il terzo grazie alle necessarie
nozioni teoriche acquisite. Nel secondo capitolo infatti, si cercher\`a di descrivere un tool di verifica 
automatica di protocolli crittografici che lavora direttamente nel modello computazionale. Infine, nel terzo capitolo,
si tenter\`a di utilizzare questo tool per provare in modo automatico un risultato classico della crittografia
computazionale che riguarda i generatori pseudocasuali. Si tenter\`a, quindi, di dare una dimostrazione automatica di un teorema che \`e gi\`a stato
dimostrato in modo non automatico e che riguarda i generatori di numeri pseudocasuali. L'utilizzo che si far\`a del tool \`e anomalo 
nel senso che il tool \`e stato progettato
per provare risultati relativi a concetti quali autenticazione e segretezza di protocolli e non teoremi riguardanti
i generatori pseudocasuali.
Infine, nelle conclusioni, si cercher\`a di \emph{tirare le somme} di questo lavoro descrivendo le difficolt\`a incontrate,
i vantaggi e gli svantaggi riscontrati nel tool.
\chapter{Il Modello Computazionale}
In questo capitolo si cercher\`a di descrivere le principali caratteristiche del modello computazionale. Saranno resi evidenti alcuni legami che
esistono fra la crittografia, la teoria della calcolabilit\`a e alcune nozioni di statistica e probababilit\`a. Sono questi infatti i cardini su cui poggia la crittografia
computazionale.\\ 
Si cercher\`a sempre di dare delle definizioni rigorose e il pi\`u possibile non ambigue. 
Si tenter\`a sempre, inoltre, di fornire delle dimostrazioni delle affermazioni che si fanno; \`e questo infatti il giusto modo di procedere.
Non \`e raro infatti, trovare esempi di schemi crittografici che sono stati ritenuti validi solo sulla base di argomentazioni approssimative e non formali e 
che non essendo stati dimostrati \emph{matematicamente} validi si sono poi rivelati tutt'altro che affidabili\footnote{Il cifrario di Vigener\`e ritenuto indecifrabile per 
moltissimi anni si può infatti violare facilmente con tecniche di tipo statistico.}.

\section{L'Avversario}
Il tipico avversario con cui si ha a che fare quando si studiano cifrari o protocolli crittografici nel modello computazionale,
è un avversario con risorse di calcolo \emph{limitate}. Limitate nel senso che si sceglie di porre un limite alla potenza di calcolo dell'avversario.
Questo significa che non avremo a che fare con un avversario che ha una capacit\`a di calcolo potenzialmente infinita o un tempo illimitato a disposizione.\\
Sebbene siano stati ideati cifrari sicuri anche rispetto ad avversari non limitati\footnote{Il cifrario \emph{one-time pad} \`e il tipico esempio di cifrario perfettamente sicuro o teoricamente sicuro.}, 
questi hanno alcuni difetti, come per esempio
il fatto che la chiave debba essere lunga quanto il messaggio o che sia utilizzabile una sola volta.
Per rappresentare in modo formale un avversario con risorse di calcolo limitate, si pu\`o rappresentare questo come un generico algoritmo appartenente ad una 
particolare classe di complessit\`a computazionale\footnote{Un avversario infatti \`e una macchina di Turing che esegue un algoritmo.}. \\
Una linea di pensiero che accomuna ogni campo dell'informatica, considera efficienti gli algoritmi che terminano in un numero di passi polinomiale nella lunghezza dell'input, e inefficienti 
quelli che hanno una complessit\`a computazionale maggiore (e.g. esponenziale). 
La scelta di porre un limite alle risorse di calcolo dell'avversario \`e dettata dal buon senso.
\`E ragionevole infatti pensare che l'attaccante non sia infinitamente potente; \`e altrettanto ragionevole pensare che un attaccante non sia disposto ad impiegare un tempo \emph{eccessivo} per violare uno schema crittografico.\\
\`E logico quindi pensare che gli avversari vogliano essere \emph{efficienti}.\\
Pu\`o sembrare quindi naturale immaginare gli avversari come degli algoritmi che terminano in un numero polinomiale di passi
rispetto alla lunghezza dell'input. Come si pu\`o notare, non si fa alcuna assunzione particolare sul comportamento dell'avversario. Le uniche cose che sappiamo sono che:
\begin{itemize}
 \item l'avversario non conosce la chiave, ma conosce l'algoritmo di cifratura utilizzato  e i parametri di sicurezza, come per esempio la lunghezza della chiave\footnote{Il principio di Kerchoffs 
(famoso crittografo olandese, 19 Gennaio 1835 - 9 Agosto 1903) afferma che
l'algoritmo di cifratura non deve essere segreto e deve poter cadere nelle mani del nemico senza inconvenienti.}. 
 \item l'avversario vuole essere efficiente, ovvero polinomiale.
\end{itemize}

Non si fanno ipotesi sull'algoritmo che questo andr\`a ad eseguire.
Per esempio dato un messaggio cifrato $c=E_k(m)$, non ci aspettiamo che l'avversario non decida di utilizzare la stringa $c'$ tale che:  $c'=D_{k'}(E_k(m))$ con $k\neq k'$. 
Ovvero, sarebbe sbagliato supporre che l'avversario non cerchi di decifrare un messaggio mediante una chiave diversa 
da quella utilizzata per cifrarlo.
Nel modello computazionale i messaggi sono trattati come sequenze di bit e non come espressioni \emph{formali}; l'avversario, nel modello computazionale, pu\`o effettuare qualsiasi operazione su un messaggio. Questa visione \`e, a differenza di quella 
che si ha nel modello formale, sicuramente molto pi\`u realistica~\cite{DBLP:conf/crypto/2006}.\\

Non bisogna per\`o dimenticare che un avversario può sempre \emph{indovinare} il segreto che cerchiamo di nascondere o che cifriamo. 
Per esempio: se il segreto che si cerca di nascondere ha una lunghezza di $n$ bit, l'avversario pu\`o sempre effettuare una scelta casuale fra il valore 0 e il valore 1 per $n$ volte.
La probabilit\`a che l'avversario ottenga una stringa uguale al segreto \`e ovviamente di $\frac{1}{2^n}$. 
Questa probabilit\`a tende a 0 in modo esponenziale al crescere della lunghezza del segreto, ma per valori finiti di $n$ questa probabilit\`a non sar\`a mai 0.
\`E quindi pi\`u realistico cercare di rappresentare l'avversario come un algoritmo che, oltre a terminare in tempo polinomiale, ha
anche la possibilit\`a di effettuare scelte casuali e di commettere errori (anche se con probabilit\`a limitata).
La classe dei problemi risolti da questo tipo di algoritmi \`e indicata con la
sigla \emph{PPT} (i.e. \emph{Probabilistic Polynomial Time}).\\Un modo pi\`u formale di vedere questo tipo di algoritmi \`e il seguente: si suppone che la macchina di Turing che 
esegue l'algoritmo, oltre a ricevere l'input, diciamo $x$, riceva anche un input ausiliario $r$. Questa stringa di bit $r$, rappresenta una possibile sequenza di lanci di moneta dove \`e stato associato al valore $0$ la croce e al valore $1$ la testa (o anche viceversa ovviamente).
Qualora la macchina dovesse effettuare una scelta casuale, non dovr\`a far altro che prendere il successivo bit dalla stringa $r$, e prendere una decisione in base ad esso
(\`e, in effetti, come se avesse preso una decisione lanciando una moneta). Ecco quindi che il nostro tipico avversario si configura come un algoritmo polinomiale probabilistico.
\`E inoltre giustificato cercare di rendere sicuri\footnote{In qualsiasi modo si possa intendere il concetto di sicurezza. Vedremo che in seguito si daranno delle definizioni rigorose di questo concetto.} gli schemi crittografici rispetto, principalmente, a questo tipo di avversario.
Non \`e quindi necessario dimostrare che un particolare schema crittografico sia inviolabile, ma basta dimostrare che:
\begin{itemize}
 \item in tempi ragionevoli lo si pu\`o violare solo con scarsissima probabilit\`a.
 \item lo si pu\`o violare con alta probabilit\`a, ma solo in tempi non ragionevoli.
\end{itemize}
Sappiamo che il concetto di \emph{tempo ragionevole} \`e catturato dalla classe degli algoritmi polinomiali probabilistici. Vediamo ora di catturare il concetto di \emph{scarsa probabilit\`a}.
\section{Funzioni Trascurabili e non $\dots$}
In crittografia i concetti di \emph{scarsa probabilit\`a} e di evento \emph{raro} vengono formalizzati attraverso la nozione di funzione trascurabile.
\begin{definizione}[Funzione Trascurabile]
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e trascurabile se e solo se per ogni polinomio $p$, esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) < \frac{1}{p(n)}$.  
\end{definizione}
Una funzione trascurabile, quindi, \`e una funzione che tende a 0 pi\`u velocemente dell'inverso di qualsiasi polinomio.
Un'altra definizione utile \`e la seguente:
\begin{definizione}[Funzione Distinguibile]
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e distinguibile se e solo se esiste un polinomio $p$, tale per cui esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) > \frac{1}{p(n)}$.  
\end{definizione}
Per esempio la funzione $n  \mapsto 2^{-\sqrt{n}}$ \`e una funzione trascurabile, mentre la funzione $n \mapsto \frac{1}{n^2}$ non lo \`e. 
Ovviamente esistono anche funzioni che non sono n\'e trascurabili n\'e distinguibili. Per esempio, la seguente funzione definita per casi:\\
$f(n) = \begin{cases} 1, & \mbox{se } n\mbox{ \`e pari} \\ 0, & \mbox{se } n\mbox{ \`e dispari} \end{cases}$\\
non \`e n\'e trascurabile n\'e distinguibile. Questo perch\'e le definizioni precedenti, pur essendo molto legate, non sono l'una la negazione dell'altra.

Se sappiamo che, in un esperimento, un evento avviene con una probabilt\`a trascurabile,
quest'evento si verificher\`a con una probabilit\`a trascurabile anche se l'esperimento viene ripetuto molte volte (ma sempre un numero polinomiale di volte), e quindi per la legge dei grandi numeri, 
con una frequenza anch'essa trascurabile\footnote{In modo informale, la legge debole dei grandi numeri afferma che: per un numero grande di prove, 
la frequenza approssima la probabilit\`a di un evento.}. 
Le funzioni trascurabili, infatti, godono di due particolari propriet\`a di chiusura, enunciate nella seguente:
\begin{proposizione}
Siano $\mu_1, \mu_2$ due funzioni trascurabili e sia $p$ un polinomio. Se $\mu_3 = \mu_1 + \mu_2$, e $\mu_4= p\cdot \mu_1$, allora $\mu_3$, $\mu_4$ sono funzioni trascurabili.  
\end{proposizione} 

Se quindi, in un esperimento, un evento avviene solo con probabilit\`a trascurabile, ci aspettiamo che, anche se ripetiamo l'esperimento un numero polinomiale di volte, questa probabilit\`a
rimanga comunque trascurabile.\\
Per esempio: supponiamo di avere un dado truccato in modo che la probabilit\`a di ottenere 1 sia trascurabile. Allora se lanciamo il dado un numero polinomiale di volte, la probabilit\`a
che esca 1 rimane comunque trascurabile.\\
\`E ora importantissimo notare che:
\textbf{gli eventi che avvengono con una probabilit\`a trascurabile possono essere ignorati per fini pratici}.
In \cite{1206501}, infatti leggiamo:
\begin{quotation}
\emph{Events that occur with negligible probability are so unlikely to occur that can be ignored for all practical purposes. Therefore,
a break of a cryptographic scheme that occurs with negligible probability is not significant.}
\end{quotation}
Potrebbe sembrare pericoloso utilizzare degli schemi crittografici che ammettono di essere violati con probabilit\`a trascurabile, ma questa possibilit\`a \`e cos\`i remota, che una tale preoccupazione \`e da ritenersi
ingiustificata.
Finora abbiamo parlato di funzioni che prendono in input un argomento non meglio specificato. 
Al crescere di questo parametro, le funzioni si comportano in modo diverso, a seconda che siano trascurabili, oppure no.
Ma cosa rappresenta nella realt\`a questo input?
Di solito, questo valore rappresenta un generico parametro di sicurezza, indipendente dal segreto. \`E comune immaginarlo come la lunghezza in bit delle chiavi.\\
D'ora in poi con affermazioni del tipo \flqq\l'algoritmo \`e polinomiale, o esponenziale\frqq, si intenderanno algoritmi polinomiali o esponenziali nella lunghezza (in bit) del parametro di sicurezza (indicato con $n$). Si utilizzer\`a questa assunzione anche quando si faranno affermazioni su funzioni trascurabili o meno. Quelle funzioni saranno trascurabili o meno nel parametro $n$.
Tutte le definizioni di sicurezza che vengono date nel modello computazionale e che utilizzano le probabilit\`a trascurabili, sono di tipo \emph{asintotico}.
Un template di definizione di sicurezza è il seguente \cite{1206501}:
\begin{quotation}
\emph{A scheme is secure if for every probablistic polynomial-time adversary \textbf{A} [...], the probability that \textbf{A} succeds in this attack [...]
is negligible}
\end{quotation}
Essendo questo schema di definizione asintotico (nel parametro di sicurezza \emph{n}), \`e ovvio che non considera valori piccoli di \emph{n}.
Quindi se si dimostra che un particolare schema crittografico \`e sicuro secondo una definizione di questo tipo, pu\`o benissimo capitare che per valori piccoli di \emph{n} lo schema
sia violabile con alta probabilit\`a e in tempi ragionevoli.
\section{Indistinguibilit\`a Computazionale}
Se due oggetti, sebbene profondamente diversi fra loro, non possono essere distinti, allora sono, da un certo punto di vista, equivalenti.
Nel caso della crittografia computazionale, due oggetti sono computazionalmente equivalenti se nessun algoritmo efficiente li pu\`o distinguere.
Possiamo immaginare che un algoritmo riesca a distinguere due oggetti, se quando gli si da in input il primo, lui da in output una costante \emph{c}, mentre se gli si 
fornisce come input il secondo da in output una costante \emph{$c'$} e ovviamente $c \neq c'$.
La definizione tipica di indistinguibilit\`a computazionale \`e data prendendo come oggetti da distinguere alcune particolari distribuzioni statistiche detti \emph{ensembles}.

\begin{definizione}[Ensemble]
Sia $I$ un insieme numerabile infinito. $X=\{X_i\}_{i \in I}$ \`e un ensemble su $I$ se e solo se \`e una sequenza di variabili statistiche, tutte con lo stesso tipo di distribuzione.
\end{definizione}
Un \emph{ensemble} \`e quindi una sequenza infinita di distribuzioni di probabilit\`a\footnote{Siccome si parla di distribuzioni su stringhe di bit con lunghezza finita,
in crittografia computazionale si considerano ensemble che sono una sequenza infinta di distribuzioni finite di stringhe di bit.}. 
Tipicamente le variabili dell'ensemble sono stringhe di lunghezza $i$. $X_i$ \`e quindi una distribuzione di probabilit\`a su stringhe di lunghezza $i$.

Ora supponiamo di avere due ensemble $X$ e $Y$. Intuitivamente queste distribuzioni sono indistinguibili se nessun algoritmo (efficiente) pu\`o accettare infiniti elementi di $X_n$
(per esempio stampando $1$ su input preso da $X_n$) e scartare infiniti elementi di $Y_n$ (per esempio stampare $0$ su input preso da $Y_n$). \`E importante notare che sarebbe facile 
distinguere due \emph{singole} distribuzioni usando un approccio esaustivo, ecco perch\'e si considerano sequenze infinite di distribuzioni finite.
In poche parole questi ensemble sono indistinguibili se ogni algoritmo (efficiente) accetta $x \in X_n$ se e solo se accetta $y \in Y_n$. Ovviamente il \emph{se e solo se} non pu\`o e non deve
essere inteso in senso \emph{classico}, ma deve essere inteso in senso statistico. Poich\'e in crittografia si \`e soliti indicare con $U_m$ una variabile
uniformemente distribuita sull'insieme delle stringhe di lunghezza $m$, chiameremo $U=\{U_n\}_{n \in \mathbb{N}}$ l'ensemble uniforme.
Dopo questa breve introduzione all'indistinguibilit\`a siamo pronti per dare una definizione rigorosa:

\begin{definizione}[Indistinguibilit\`a computazionale]
Due ensemble $X=\{X_n\}$, $Y=\{Y_n\}$ sono computazionalmente indistinguibili se e solo se per ogni algoritmo $D \in PPT$ (detto distinguitore) esiste $\mu$ trascurabile tale che:
\begin{center}$\lvert Pr[D(1^n, X_n) = 1] - Pr[D(1^n, Y_n) = 1] \rvert \leq \mu(n)$.\end{center}
\end{definizione}
Nella definizione precedente: $Pr[D(1^n, X_n) = 1]$ \`e la probabilit\`a che, scegliendo $x$ secondo la distribuzione $X_n$ e fornendo questo valore al distinguitore insieme al valore $1^n$, il distinguitore stampi $1$.
Il fatto che al distinguitore si fornisca anche il valore del parametro di sicurezza in base unaria, serve ad esser sicuri che in ogni caso il distinguitore impieghi un tempo polinomiale 
nel parametro di sicurezza.
Infatti, il distinguitore quando si trover\`a a dover leggere il primo parametro, necessariamente impiegher\`a un tempo polinomiale nel parametro di sicurezza, visto che questo \`e stato 
fornito in base unaria\footnote{Ignoreremo, d'ora in poi, questo cavillo formale.}.

La definizione di indistinguibilit\`a computazionale cattura quindi il seguente concetto: se due ensemble sono computazionalmente indistinguibili, 
allora la probababilit\`a che un distinguitore riesca a discernere i valori provenienti da un insieme rispetto all'altro \`e trascurabile; di conseguenza agli occhi del distinguitore 
gli ensemble non sono differenti e quindi sono per lui equivalenti (o meglio computazionalmente equivalenti o ancora, indistinguibili in tempo polinomiale). 
Non \`e raro, nell'ambito scientifico in particolare, basarsi sul concetto generale di indistinguibilit\`a al fine di creare nuove classi di equivalenza di oggetti.
\begin{quotation}
\emph{The concept of efficient computation leads naturally to a new kind of equivalence between objects: Objects are considered to be computationally equivalent if they cannot be
differentiated by any efficient procedure. We note that considering indistinguishable objects as equivalent is one of the basics paradigms of both science and real-life situations. Hence,
we believe that the notion of computational indistinguishability is a very natural one~\cite{519078}.}
\end{quotation}


\section{Pseudocasualit\`a e Generatori Pseudocasuali}
Argomento centrale di questa sezione \`e il concetto di \emph{pseudocasualit\`a} applicato a stringhe di bit di lunghezza finita.
Parlare di pseudocasualit\`a applicata ad una \emph{singola} stringa, ha poco senso quanto ne ha poco parlare di singola stringa casuale.
Il concetto di casualit\`a (come quello di pseudocasualit\`a) si applica, infatti, a distribuzioni di oggetti (stringhe di bit nel nostro caso) e non a singoli oggetti.\\
La nozione di casualit\`a \`e fortemente legata a quella di distribuzione uniforme. Un insieme di oggetti \`e caratterizzato
da una distribuzione uniforme se la probabilit\`a \`e equamente distribuita su tutti gli oggetti. Quindi \emph{l'estrazione} di un elemento \`e del tutto casuale, 
perch\'e non ci sono elementi pi\`u probabili di altri.

Il concetto di pseudocasualit\`a \`e un caso particolare di indistinguibilit\`a, infatti una distribuzione \`e \emph{pseudocasuale} se nessuna procedura efficiente, 
pu\`o distinguerla dalla distribuzione uniforme.
\begin{definizione}[Pseudocasualit\`a]
L'ensemble $X=\{X_n\}_{n \in \mathbb{N}}$ \`e detto pseudocasuale se e solo se $ \exists l:$ $\mathbb{N}\rightarrow\mathbb{N}$ tale che: 
$X$ \`e computazionalmente indistinguibile da $U=\{U_{l(n)}\}_{n \in \mathbb{N}} $.  
\end{definizione}
Data questa definizione, possiamo finalmente definire formalmente cosa sia un generatore pseudocasuale.
\begin{definizione}[Generatore Pseudocasuale]
Sia $l:$ $\mathbb{N}\rightarrow\mathbb{N}$ un polinomio detto fattore d'espansione. 
Sia G un algoritmo polinomiale deterministico tale che: $\forall s \in \{0, 1\}^{n}$ $G(s) \in \{0, 1\}^{l(n)}.$
Allora $G$ \`e un generatore pseudocasuale se e solo se valgono le seguenti condizioni:
\begin{itemize}
 \item Espansione: $\forall n: l(n) > n$
 \item Pseudocasualit\`a: $\forall D \in PPT, \exists \mu$ trascurabile tale che \begin{center}
                                                   $\lvert Pr[D(r) = 1] - Pr[D(G(s)) = 1]\rvert$                               
                                                                                 \end{center} 
con $r \in U_{l(n)}$ e $s \in U_{n}$
\end{itemize}
\end{definizione}

Quindi: se data una stringa di bit $s \in U_{n}$, nessun distinguitore efficiente riesce a distinguere (con una probabilit\`a non trascurabile) $G(s)$ da una stringa $r \in U_{l(n)}$, allora 
$G$ \`e un generatore pseudocasuale. Il suo output, infatti, non \`e distinguibile dalla distribuzione effettivamente uniforme.

\`E importante per\`o notare, che la distribuzione di stringhe in output di un generatore pseudocasuale \`e fortemente differente dalla distribuzione effettivamente casuale. Per rendere pi\`u chiara questa distinzione procederemo
con un importante esempio.
Supponiamo di avere un generatore pseudocasuale \emph{G} con fattore d'espansione $l(n)=2n$.
L'insieme $A=\{0, 1\}^{2n}$ ha, ovviamente, una cardinalit\`a pari a $2^{2n}$. Fissando quindi una certa stringa $x \in A$, 
questa ha una probabilit\`a di esser scelta in maniera casuale pari a: $\frac{1}{\lvert A \rvert} = \frac{1}{2^{2n}}$.

Ragioniamo adesso sull'output del generatore $G$. Questo prende un input appartenente al dominio: $B=\{0, 1\}^{n}$. 
Anche considerando il caso \emph{migliore} di un generatore iniettivo\footnote{Una generica funzione $f$ \`e iniettiva se e solo se $\forall x_1, x_2:$ $x_1 \neq x_2 \Rightarrow f(x_1) \neq f(x_2)$.},
il codominio di $G$ avr\`a una cardinalit\`a pari a quella del dominio ovvero $2^{n}$. La maggior parte degli elementi dell'insieme $A$ non ricadr\`a 
nell'output di $G$; questo a causa dell'abissale differenza di cardinalit\`a fra gli insiemi $G(B)$ e $A$.
Quindi la probabilit\`a che una stringa scelta in maniera uniforme dall'insieme $A$ ricada nel codominio di $G$ \`e di $\frac{2^{n}}{2^{2n}}$, cio\`e $2^{-n}$.
In teoria, quindi, \`e facile immaginare un distinguitore $D$ che riesca a discernere l'output di $G$ dalla distribuzione uniforme con probabilit\`a non trascurabile.
Supponiamo che $D$ prenda in input $y \in A$. Tutto ci\`o che $D$ deve fare \`e ricercare in modo esaustivo un $w \in B$ tale che $G(w) = y$.
Se $y \in G(B)$ allora $D$ se ne accorger\`a con probabilit\`a 1, mentre se $y$ \`e stato scelto in maniera uniforme dall'insieme $A$, $D$ stamper\`a 1 con probabilit\`a $2^{-n}$. 
\newpage Quindi abbiamo che:
\begin{center}
$\lvert Pr[D(r)=1] - Pr[D(G(s))=1]\rvert \geq 1 - 2^{-n}$
\end{center} 
con $r \xleftarrow{R} A$ e $s \xleftarrow{R} B$~\footnote{Con la notazione $s \xleftarrow{R} O$, si intende la scelta dell'elemento 
$s \in O$ in maniera casuale.}.\\
Il membro a destra della disequazione \`e una funzione distinguibile. Sembrerebbe quindi che $G$ non sia un generatore pseudocasuale.
C'\`e un' importante constatazione da fare per\`o. Il distinguitore $D$ non \`e efficiente! Infatti impiega un tempo esponenziale nel parametro $n$, e non polinomiale.
La distribuzione generata da $G$ dunque, \`e si ben lontana dall'essere uniforme, ma questo non \`e importante dal momento che nessun distinguitore che viaggia in tempo polinomiale pu\`o 
accorgersene.


Nella pratica lo scopo di $G$ \`e prendere in input un $seed$ casuale, e da quello generare una variabile pseudocasuale molto pi\`u lunga. Si intuisce da questo la grandissima
importanza che hanno i generatori pseudocasuali in crittografia. Per esempio il seed potrebbe corrispondere alla chiave di un cifrario, mentre l'output di $G$ di lunghezza $k$ potrebbe
essere il valore con cui viene fatto lo $XOR$ del messaggio (anch'esso di lunghezza $k$); otteniamo cos\`i una versione del one-time pad basato su una chiave pi\`u corta del messaggio.
Siccome una stringa pseudocasuale appare, ad un distinguitore efficiente $D$, come una stringa casuale, $D$ non ottiene un vantaggio sensibile nel passaggio dal vero one-time pad
al one-time pad che usa una chiave pseudocasuale. In generale i generatori pseudocasuali sono molto utili in crittografia per creare schemi crittografici simmetrici.

\section{Dimostrazioni Basate su Game}
In questo paragrafo si cercher\`a di spiegare cosa siano, nell'ambito della crittografia, i \emph{game}\footnote{Che intenderemo letteralmente come "giochi".} e come siano strutturate la
maggior parte delle dimostrazioni che utilizzano sequenze di giochi.\\Si possono trovare approfondimenti riguardo a questi concetti nel lavoro di Shoup \cite{shoup}.
Quella basata sul concetto di gioco \`e una tecnica\footnote{Game hopping technique.} molto utilizzata per provare la sicurezza di primitive crittografiche o di protocolli crittografici.
Questi game sono giocati da un' ipotetica entit\`a maligna, l'attaccante, e da un'ipotetica parte benigna di solito chiamata sfidante\footnote{Perch\'e \emph{sfida} l'attaccante a 
vincere questo gioco.}. 
\`E difficile dare una definizione formale di gioco; infatti il concetto di gioco cambia, sebbene in maniera non considerevole, da situazione a situazione, da ambiente ad ambiente e 
da dimostrazione a dimostrazione (sia che queste siano fatte manualmente, sia che queste siano automatiche e quindi dipendenti dal framework in cui vengono costruite).
Intuitivamente per\`o, i giochi possono essere immaginati come un insieme di azioni, modellate in una particolare algebra di processi, 
che servono a specificare il comportamento dei partecipanti al gioco, ovvero le entit\`a che partecipano come \emph{principals} al protocollo crittografico.\\
Il lettore trover\`a utile pensarli, almeno nell'ambito di questa tesi, come insiemi di processi che, fra le altre cose, forniscono un'interfaccia all'attaccante attraverso degli 
\emph{oracoli} che possono resitituire dei valori all'attaccante. Questi oracoli, prima di restituire il valore, possono effettuare calcoli, dichiarare ed utilizzare variabili che non saranno
visibili all'esterno.\\Si deve pensare agli oracoli come a delle scatole nere inaccessibili dall'esterno. Questi oracoli, una volta interrogati, forniscono una risposta,
e questo \`e il massimo livello di interazione che dall'esterno si pu\`o avere con queste entit\`a.\\ \\
Il primo passo che le dimostrazioni di sicurezza basate su sequenze di giochi fanno, \`e quello di modellare il protocollo crittografico reale in un gioco iniziale $G_0$.
In $G_0$ esiste la probabilit\`a non nulla che un evento \emph{negativo} possa accadere (immaginiamolo come una sorta di vittoria da parte dell'attaccante).
Ora, in generale, si procede effettuando delle modifiche al gioco $G_i$ ottenendo un gioco $G_{i+1}$ 
tale che $G_i$ e $G_{i+1}$ siano computazionalmente indistinguibili. Le modifiche che si effettuano fra un gioco e un altro devono introdurre delle differenze computazionalmente irrilevanti.
Queste modifiche possono essere viste come regole di riscrittura delle distribuzioni di probabilit\`a delle variabili utilizzate nei giochi.
Se, per esempio, in un gioco $G_i$ un processo ha a che fare con un variabile casuale, e nel gioco $G_{i+1}$ questa viene sostituita con una variabile che invece \`e pseudocasuale, non vengono introdotte
modifiche computazionalmente rilevanti e quindi il passaggio \`e lecito, visto che i due giochi non sono distinguibili se non con 
probabilit\`a trascurabile\footnote{In teoria si pu\`o ammettere anche un passaggio da gioco a gioco che valga
con probabilit\`a $p$ non trascurabile, ovvio che poi si giunger\`a ad un gioco finale che sar\`a distinguibile 
da quello iniziale per una probabilit\`a non trascurabile di valore almeno $p$. Quindi questo tipo di passaggio non \`e utile.}.
Alla fine si arriva ad un gioco $G_f$ in cui \emph{l'evento} non pu\`o accadere. Se l'evento non pu\`o accadere, l'attaccante non ha possibilit\`a di vincere. 
Se, quindi, nel gioco finale l'attaccante non ha possibilit\`a di vincere e il gioco finale
\`e computazionalmente indistinguibile dal penultimo, questo lo \`e dal terzultimo e cos\`i via fino a $G_0$, allora
il gioco finale \`e computazionalmente indistinguibile dal primo\footnote{Ricordiamo infatti che la somma di due probabilit\`a trascurabili rimane trascurabile.}. 
Adesso, quindi, se nel gioco iniziale esiste la possibilit\`a che un evento avvenga, e nel gioco finale no,
si pu\`o dare un limite superiore alla probabilit\`a che l'evento avvenga nel gioco iniziale. Questo limite \`e la somma di tutte le probabilit\`a con cui un attaccante riesce a distinguere un gioco dal successivo all'interno della sequenza.

\`E importante dire che anche nel modello formale si possono utilizzare le sequenze di giochi. La differenza \`e che due giochi successivi non sono computazionalmente indistinguibili, 
ma sono perfettamente indistinguibili. In particolare quello che si vuole sottolineare \`e che se in una sequenza di giochi $G_b$ e $G_a$ sono l'uno il successore dell'altro, 
allora i due giochi 
devono appartenere ad una stessa classe di equivalenza che \`e indotta dalla particolare relazione di equivalenza che il modello in cui si sta costruendo la catena di giochi sfrutta.
Nel modello formale questa relazione sar\`a l'indistinguibilit\`a perfetta (meglio nota come equivalenza osservazionale) mentre in quello computazionale sar\`a 
l'indistinguibilit\`a computazionale.
\chapter{CryptoVerif}
CryptoVerif \`e un \emph{dimostratore} automatico di sviluppo abbastanza recente\footnote{La sua prima release stabile risale al 2006.} che lavora direttamente nel modello computazionale.\\
CryptoVerif \`e stato scritto da Bruno Blanchet\footnote{Ricercatore al LIENS (Computer Science Laboratory of Ecole Normale Supérieure)} nel linguaggio di programmazione OCaml. 
Si possono trovare pi\`u informazioni riguardo al tool nella home page di Blanchet\footnote{\url{http://www.di.ens.fr/~blanchet/index-eng.html}}.
Questo tool \`e utilizzato di solito per dimostrare propriet\`a di segretezza e autenticazione. Le prove in questione  si basano sulla tecnica delle sequenze di giochi.
Il tool \`e liberamente scaricabile\footnote{\url{http://www.cryptoverif.ens.fr/cryptoverif.html}} sotto la licenza CeCill\footnote{\url{http://www.cecill.info/licences/}}.
CryptVerif \`e stato gi\`a utilizzato per dimostrare la correttezza di alcuni protocolli crittografici o schemi di firma, come per esempio: FDH \cite{BlanchetPointchevalCrypto06}, 
Kerberos \cite{BlanchetJaggardScedrovTsayAsiaCCS08}.\\
Scopo di questo capitolo \`e quello di descrivere, in modo non troppo formale\footnote{Nel senso che la semantica formale non sar\`a trattata rigorosamente. Il lettore interessato all'argomento pu\`o comunque trovare pi\`u informazioni in \cite{BlanchetJaggardScedrovTsayAsiaCCS08}}, 
un sottoinsieme del linguaggio che CryptoVerif implementa, in modo da poter leggere il capitolo successivo con le conoscenze necessarie.
Alla fine del capitolo verr\`a descritta brevemente l'implementazione dello schema di firma FDH nel linguaggio di CryptoVerif.
\newpage
\section{La Sintassi}
Di seguito si cercher\`a di fornire maggiori spiegazioni senza per\`o, per ora, entrare troppo nel dettaglio.
Un tipico file di input per CryptoVerif ha la seguente forma: \\
\begin{center}
\verb!<declaration>!$^{*}$\verb! process <odef>!.
\end{center}
\subsection{Dichiarazioni}
Una dichiarazione (declaration) fornisce a CryptoVerif delle informazioni su come comportarsi nella dimostrazione; 
spesso \`e la descrizione di una primitiva crittografica che CryptoVerif pu\`o assumere come vera per costruire le sue prove.
In generale una dichiarazione pu\`o essere:
\begin{description}
 \item{\emph{Simbolo funzionale}.} La dichiarazione di una funzione si d\`a insieme ai tipi dei parametri in input (se ce ne sono) e il tipo del valore di ritorno. Per esempio, con il seguente frammento di codice:\\
				      \begin{verbatim}
				       fun kgen(keyseed):key.
				      \end{verbatim}	   
si dichiara una funzione \verb!kgen: keyseed!$\rightarrow$ \verb!key!. Intuitivamente il simbolo $\texttt{kgen}$ rappresenta una funzione per generare chiavi crittografiche a partire semi casuali.
 \item{\emph{Tipo}.} L'utente pu\`o definire dei propri tipi i cui valori saranno trattati come stringhe di bit.
	    Ovvero i valori dei tipi sono sempre dei sottoinsiemi di propri $\{0, 1\}^*$. Per esempio, con il seguente frammento di codice:
  				      \begin{verbatim}
				       type keyseed[fixed].
				      \end{verbatim}
si dichiara un nuovo tipo $\texttt{keyseed}$. La parola chiave $\texttt{fixed}$ serve ad informare CryptoVerif che \`e possibile estrarre valori casuali da quell'insieme.
Un'altra opzione molto utilizzata \`e $\texttt{large}$. Un tipo dichiarato come $\texttt{large}$ gode della propriet\`a che, scegliendo casualmente due valori dal dominio del tipo, la probabilit\`a di ottenere
due valori identici \`e bassa.
 \item{\emph{Propriet\`a}.} \`E possibile modellare alcune propriet\`a dei simboli di funzione che si specificano, come per esempio l'iniettivit\`a oppure la monotonia. Per esempio, con il seguente frammento di codice:
    				      \begin{verbatim}
				    forall x, y: myType; (f(x) = f(y)) = (y = x).
				      \end{verbatim}
definiamo l'iniettivit\`a della funzione $\texttt{f}$. Infatti possiamo sostituire il membro a sinistra dell'equazione con quello di destra solo se la funzione $\texttt{f}$ \`e iniettiva.
 \item{\emph{Regola di Riscrittura}.} La dichiarazione di una regola di riscrittura consiste in una coppia di espressioni. Ogniqualvolta CrytptoVerif incontra la prima
			      pu\`o decidere di sostituirla con la seconda. Per esempio, con il seguente frammento di codice:
      				      \begin{verbatim}
				      not(not(true))=false.
				      not(not(false))=true.
				      \end{verbatim}
informiamo CryptoVerif che ogniqualvolta incontra una doppia negazione del valore $\texttt{true}$ pu\`o sostituirlo con il valore $\texttt{false}$, e viceversa. 
Si badi: se si dessero, invece delle precedenti, queste regole di riscrittura:
				      \begin{verbatim}
				      false=not(not(true)).
				      true=not(not(false)).
				      \end{verbatim}
si andrebbe probabilmente incontro ad un loop infinito durante la fase di elaborazione di CryptoVerif. Infatti nel momento in cui il tool riconoscesse nel codice il valore $\texttt{true}$, 
procederebbe con una riscrittura di questo nel frammento $\texttt{not(not(false))}$ il quale a sua volta sarebbe riscritto in $\texttt{not(not(not(not(true))))}$ e cos\`i via senza poter mai terminare.
 \item{\emph{Probabilit\`a}.} In CryptoVerif \`e possibile dichiarare delle probabilit\`a. Le probabilit\`a non solo possono essere trattate come \emph{oggetti} (numeri) 
		      a se stanti, ovvero come dei valori statici, ma possono anche essere utilizzate come funzioni di altri argomenti. Con il seguente frammento di codice:
				      \begin{verbatim}
				      proba POW.
				      \end{verbatim}
si dichiara una probabilit\`a $\texttt{POW}$. 
 \item{\emph{Costante}.} Dichiarando una costante $\texttt{k}$ si comunica a CryptoVerif che quel dato, una volta inizializzato, non potr\`a cambiare valore durante l'esecuzione del protocollo. Per esempio, con il seguente frammento di codice:
				      \begin{verbatim}
				      const mark:bitstring.
				      \end{verbatim}
	Si dichiara una costante chiamata $\texttt{mark}$ di tipo $\texttt{bitstring}$.
 \item{\emph{Evento}.} Un evento permette di rappresentare alcune particolari situazioni nel flusso d'esecuzione del protocollo in esame. 
		Per esempio: si potrebbe
		pensare di dichiarare un evento \emph{forge} da \emph{sollevare} nel momento in cui un avversario riesca a \emph{forgiare} una firma
		valida per un messaggio mediante il seguente frammento di codice:
				      \begin{verbatim}
				      event forge.
				      \end{verbatim} .
	      Si osservi ora il seguente codice: 
 				      \begin{verbatim}
   find u <= qS suchthat defined(m[u]) && (m' = m[u]) then 
       end
   else      
      event forge.
				      \end{verbatim}
il costrutto $\texttt{find}$ verr\`a analizzato successivamente, per ora \`e sufficiente sapere che il costrutto $\texttt{find}$ ha un ramo che viene eseguito quando una particolare condizione \`e verificata (il ramo then) e un ramo che
viene seguito quando la condizione del ramo then non si verifica (ramo else). Nel frammento precedente non ci sono dichiarazioni, infatti il frammento serve per dare un esempio di come
sollevare un evento. Nel ramo else, dunque, viene sollevato l'evento forge. Infatti, come sar\`a meglio spiegato nel paragrafo relativo all'esempio FDH, il ramo else rappresenta la situazione in cui un avversario ha fornito
una coppia $\texttt{(m,} $ $\sigma \texttt{)}$ tale che $\sigma$ \`e una firma valida per il messaggio $\texttt{m}$ e nessun oracolo ha mai rilasciato tale firma.
 \item{\emph{Equivalenza}.} La dichiarazione di un'equivalenza fra giochi permette di dare a CryptoVerif una regola di riscrittura che pu\`o valere
		    a meno di una certa probabilit\`a (eventualmente nulla). Affermando che un gioco \`e equivalente ad un altro a meno di una certa probabilit\`a, 
		    si d\`a la possibilit\`a al tool di sostituire espressioni che compaiono nel primo gioco con le equivalenti che compaiono nel secondo, 
tenendo comunque conto della probabilit\`a in gioco. Pi\`u in generale, quando si d\`a un'equivalenza fra giochi a meno di una certa probabilit\`a $\texttt{p}$ si comunica a CryptoVerif
che i giochi in questione non possono essere distinti con una probabilit\`a maggiore di $\texttt{p}$. Ovviamente se la probabilit\`a \`e nulla allora i giochi non possono essere distinti.
Per esempio, con il seguente frammento di codice:
\begin{verbatim}
equiv 
      foreach iK <= nK do r <-R seed; (
          Opk() := return(pkgen(r)) |
          foreach iF <= nF do x <-R D;
           (Oant() := return(invf(skgen(r),x)) |
            Oim() := return(x)
               )
           )
   <=(0)=>
      foreach iK <= nK do r <-R seed; (
         Opk() := return(pkgen(r)) |
         foreach iF <= nF do x <-R D;
          (Oant() := return(x) |
                   Oim() := return(f(pkgen(r), x))
              )
          )
 \end{verbatim}
si definisce un'equivalenza fra giochi che permette di definire $\texttt{invf}$ come funzione inversa di $\texttt{f}$. I giochi in questione sono rispettivamente quello a sinistra e quello a destra dei simboli $\texttt{<=(0)=>}$.
Poich\'e quest'equivalenza deve valere sempre e non a meno di una probabilit\`a, la quantit\`a tra parentesi \`e zero (fra i due giochi). 
 \item{\emph{Parametro}.} Un parametro (di cui si sa solo che assumer\`a valori polinomiali nel parametro di sicurezza) pu\`o essere utilizzato per vari scopi.
		  Il pi\`u importante \`e sicuramente effettuare lookup in array che contengono un numero di oggetti pari al parametro.
Per esempio, con il seguente codice:
\begin{verbatim}
param qS.
\end{verbatim}
si dichiara un parametro $\texttt{qS}$ di cui sappiamo che assumer\`a valori polinomiali nel parametro di sicurezza.	    
 \item{\emph{Oracolo}.} \`E possibile dichiarare oracoli aggiuntivi che successivamente possono essere richiamati durante l'esecuzione
			  del protocollo crittografico. Un oracolo\footnote{Il concetto di oracolo qui non ha molto a che fare con gli oracoli che spesso si trattano in altri ambiti dell'informatica.}, in CryptoVerif, non \`e altro che un processo che pu\`o prendere
			  dei dati in input e restituirne in output. Un oracolo pu\`o, nel suo corpo, effettuare dei calcoli i quali devono
			  essere considerati invisibili per un ipotetico attaccante. Per esempio, con il seguente frammento di codice:
 \begin{verbatim}
   let processS =
     foreach iS <= qS do
     OS(m:bitstring) :=
      return(invf(sk, hash(m))).
 \end{verbatim}
si dichiara un processo $\texttt{processS}$ che non \`e altro che la replicazione, limitata polinomialmente dal parametro $\texttt{qS}$, dell'oracolo $\texttt{OS}$, il cui corpo \`e un'istruzione che ritorna un valore.
 \item{\emph{Query}.} Mediante un'istruzione di query \`e possibile istruire il tool su cosa si vuole venga dimostrato. Si potrebbe infatti richiedere
		    al tool di dimostrare l'indistinguibilit\`a di una variabile da un oggetto casuale, provandone cos\`i la pseudocasualit\`a.	Per esempio, con il seguente frammento di codice:
\begin{verbatim}
 query secret1 x.
\end{verbatim}
si chiede a CryptoVerif di cercare di dimostrare che $x$ \`e indistinguibile da una stringa casuale.
\end{description}
Di solito la maggior parte delle dichiarazioni (o comunque quelle pi\`u importanti e utilizzate) vengono fornite a CryptoVerif in un file separato (una sorta di libreria). 
Grazie a questa possibilit\`a \`e possibile dare una volta per tutte alcune definizioni molto utili in crittografia (e.g funzione one-way) e, 
una volta fatto, \`e possibile utilizzarle in tutti gli schemi crittografici che le utilizzano semplicemente specificando il file di libreria corretto.
\subsection{Definizione del protocollo}
Dopo una serie di dichiarazioni, si procede inserendo la parola chiave $\texttt{process}$ e si continua specificando, mediante un oracolo, il protocollo di cui si desiderano dimostare delle propriet\`a. 
In CryptoVerif, come gi\`a detto, un oracolo non \`e altro che un processo o un'opportuna composizione di processi. 
I processi sono specificati mediante un calcolo di processi; questo mette a disposizione vari operatori per comporre in vario modo dei processi di base, al fine di ottenere
ancora dei processi. Per esempio, dati due processi $A$ e $B$ \`e possibile ottenere un altro processo $A|B$ (leggasi $A$ parallelo $B$) in cui i due processi
sono eseguiti in parallelo; oppure \`e possibile ottenere il processo $A;B$ che \`e un processo che esegue $A$ e poi esegue $B$. \`E possibile inoltre avere
un particolare tipo di parallelismo in cui si crea un numero di copie, limitato polinomialmente, di un particolare processo (in questo CryptoVerif
si \`e sicuramente ispirato \cite{MitchellRST06}. Quest'ultimo lavoro si \`e ispirato a sua volta
a \cite{AbadiG99} introducendo per\`o un'innovazione che \`e appunto la nozione di replicazione limitata polinomialmente). I processi nell'ambito della descrizione dei protocolli crittografici
devono essere intesi come le entit\`a che nel mondo reale utilizzano il protocollo stesso. Se per esempio un protocollo prevede che un utente $A$ spedisca un messaggio cifrato ad un 
utente $B$ si pu\`o pensare di modellare sia $A$ che $B$ attraverso due processi separati. Attraverso la grammatica in BNF che segue possiamo descrivere in modo pi\`u formale 
la composizione di oracoli.\\
\begin{verbatim}
<odef> ::= <ident>
        | (<odef>)
        | 0
        | <odef> | <odef>
        | foreach <ident> <= <ident> do <odef>
        | <ident> (seq <pattern> ) := <obody>
\end{verbatim} 
Dove $\texttt{seq <X>}$ \`e una qualsiasi sequenza finita di $\texttt{X}$.
Si noti la terza produzione in cui si specifica che l'oracolo \emph{nullo} (ovvero quello che non fa nulla) \`e un oracolo valido all'interno del calcolo. O ancora, un oracolo pu\`o essere la composizione parallela di
pi\`u oracoli o la replica limitata da un valore un polinomiale\footnote{Ovviamente polinomiale nel parametro di sicurezza.} (mediante il $\texttt{foreach}$) di un altro oracolo. Il fatto che un oracolo possa essere composto in maniera sequenziale con un altro oracolo
verr\`a spiegato meglio a breve.


Abbiamo parlato di modi di comporre oracoli per ottenere altri oracoli; non abbiamo per\`o descritto cosa pu\`o fare un oracolo, in particolare non si \`e 
descritto come questi siano costruiti.
Le operazioni che pu\`o fare sono varie, infatti pu\`o:
\begin{itemize}
 \item terminare.
 \item ritornare un valore al chiamante (che pu\`o essere anche l'attaccante).
 \item sollevare un evento.
 \item assegnare ad una variabile un valore, il quale pu\`o essere anche il risultato restituito da un altro oracolo
 \item assegnare ad un variabile un valore scelto casualmente da un particolare dominio.
 \item avere comportamenti diversi a seconda dell'esito di un test.
 \item ricercare elementi all'interno di un array.
\end{itemize}
Il corpo di un oracolo pu\`o essere descritto in maniera pi\`u formale attraverso la seguente grammatica in BNF:

\begin{verbatim}
<obody> ::= <ident>
          | ( <obody> )
          | end
          | event <ident> [(seq <term> )] [; <obody> ]
          | <ident> <-R <ident> [; <obody> ]
          | <ident> [: <ident> ] <- <term> [; <obody> ]
          | let <pattern> = <term> [in <obody> [else <obody> ]]
          | if <cond> then <obody> [else <obody> ]
          | find [[unique]] <findbranch> (orfind <findbranch> )∗ 
                    [else <obody> ]
          | return(seq <term> )[; <odef> ]
\end{verbatim}

Innanzi tutto si noti come in questa grammatica, grazie all'ultima produzione, sia possibile ritornare alla grammatica predecedentemente esposta il cui simbolo iniziale era $\texttt{<odef>}$; questo perch\'e deve
essere possibile alla fine dell'implementazione di un oracolo definirne un altro in modo da avere un costrutto per la sequenzializzazione degli oracoli. 
Infatti, dopo un $\texttt{return}$, mediante il simbolo di sequenzializzazione (il simbolo ``;``), \`e possibile definire un oracolo che verr\`a eseguito dopo quello precedente.
\`E importante notare il costrutto $\texttt{let}$ con il quale \`e possibile cercare di decomporre il valore a destra del simbolo di uguaglianza in un pattern specificato e, 
a seconda che questa decomposizione abbia o meno successo, \`e possibile richiamare un oracolo o un altro. 
Un pattern pu\`o essere:
\begin{itemize}
 \item una variabile.
 \item una tupla di valori. 
\end{itemize}
Per esempio, il frammento di codice:
\begin{verbatim}
 let x = A(r) in
 return(x) 
\end{verbatim}
non fa altro che assegnare ad $\texttt{x}$ (che pu\`o anche non essere dichiarata e il cui tipo viene inferito dal tipo di ritorno di $\texttt{A}$) il valore che $\texttt{A}$ ritorna su input $\texttt{r}$, e poi ritorna il valore di $\texttt{x}$.
Si noti che se, come nel caso precedente, il pattern \`e una variabile, l'effetto, da un punto di vista pratico, \`e un semplice assegnamento di un valore ad una variabile.
Questo assegnamento ha sempre successo, e degenera quindi in una dichiarazione e inizializzazione di una variabile il cui \emph{scope} \`e l'oracolo che si trova dopo la parola chiave $\texttt{in}$; 
se il pattern \`e una variabile quindi, il ramo $\texttt{else}$ non viene mai eseguito.
Come gi\`a accennato \`e possibile assegnare dei valori scelti in maniera casuale a delle variabili. Se per esempio $\texttt{x}$ \`e una variabile e $\texttt{D}$ \`e un tipo dichiarato
con la clausola $\texttt{fixed}$, allora il seguente codice:
\begin{verbatim}
 x <-R D;
\end{verbatim}
assegna ad $\texttt{x}$ un valore scelto in maniera casuale da $\texttt{D}$. In questo tipo di assegnamento a destra troviamo sempre un dominio di valori dichiarato precedentemente con la clausola $\texttt{fixed}$ \\
L'assegnamento non casuale invece ha la seguente forma:
\begin{verbatim}
 x:Type <- G(r);
\end{verbatim}
con il codice precedente si dichiara $\texttt{x}$ come variabile di tipo $\texttt{Type}$ e si assegna a questa il valore ritornato da $\texttt{G}$. 
Si osservi ora come nel seguente frammento di codice:
\begin{verbatim}
MyOracle() :=
    r <-R A;
    x:MyType <- f(r);
    return(x);
    (Z | X | Y)
\end{verbatim}
venga definito il corpo dell'oracolo $\texttt{MyOracle}$. In $\texttt{MyOracle}$ per prima cosa si assegna alla variabile $\texttt{r}$ un valore scelto casualmente dall'insieme dei valori del tipo $\texttt{A}$,
successivamente si assegna alla variabile $\texttt{x}$ il valore resitutito dalla funzione $\texttt{f}$ applicato al valore $\texttt{r}$, infine si ritorna il valore $\texttt{x}$, successivamente viene eseguito un altro processo
che \`e il risultato della composizione in parallelo dei processi $\texttt{Z}$, $\texttt{X}$ e $\texttt{Y}$. 


Un costrutto fondamentale del linguaggio implementato da CryptoVerif \`e il costrutto $\texttt{find}$\footnote{Come si afferma anche in \cite{BlanchetPointchevalCrypto06} \`e probabilmente il maggior apporto 
fornito da questo tool rispetto ad altri linguaggi che lavorano invece su liste.} 
che permette di effettuare un lookup su un array alla ricerca di elementi che soddisfino particolari propriet\`a. Inoltre, permette di compiere azioni diverse a seconda che 
questi elementi vengano trovati o meno. Un tipico esempio di utilizzo del costrutto $\texttt{find}$ pu\`o essere il seguente frammento di codice:
\begin{verbatim}
 let processT =
      OT(m':bitstring, s:D) :=
      if f(pk, s) = hash(m') then
      find i <= qS suchthat defined(m[i]) && (m' = m[i]) then 
          end 
      else
          event forge.
\end{verbatim}
In questo frammento viene definito un processo $\texttt{processT}$ come un oracolo $\texttt{OT}$ che prende in input degli argomenti e che, quando viene chiamato, effettua un test; se questo \`e positivo esegue il ramo
$\texttt{then}$ dell'$\texttt{if}$. Nel ramo $\texttt{then}$ viene effettuata una ricerca nell'array $\texttt{m}$ mediante il contatore $\texttt{i}$. Se viene trovato un $\texttt{i}$ tale per cui l'iesimo elemento dell'array $\texttt{m}$ \`e definito (ovvero gli \`e stato
precedentemente assegnato un valore) e tale per cui l'iesimo elemento dell'array ha un valore uguale a quello fornito in input, allora viene eseguito il ramo $\texttt{then}$ del $\texttt{find}$ che \`e semplicemente
la terminazione dell'oracolo.
Il costrutto $\texttt{find}$ permette anche la scansione di diversi array, ovvero si pu\`o effettuare una ricerca all'interno di diversi array cercando elementi che verifichino diverse condizioni.
Se diverse condizioni vengono verificate e quindi c'\`e la possibilit\`a che debbano essere eseguiti diversi rami $\texttt{then}$ allora CryptoVerif 
ne sceglie uno casualmente ed esegue quello.


\section{La Tecnica di Dimostrazione}
Come gi\`a detto in precedenza CryptoVerif basa le sue prove sulla tecnica delle sequenze di giochi. Questi giochi per\`o differiscono fra loro
di probabilit\`a che non sono trattate asintoticamente. Infatti, come spiegato pi\`u avanti CryptoVerif si basa sul modello delle probabilit\`a esatto e non asintotico.
CryptoVerif parte da un gioco iniziale fornito dall'utente 
(in cui un evento negativo pu\`o accadere\footnote{In questo contesto con evento non si intende necessariamento un oggetto 
dichiarato con il costrutto $\texttt{event}$ ma una qualsiasi situazione \emph{negativa} per il protocollo.}) e mediante equivalenze, 
che possono o meno
introdurre differenze, cerca di modificare un gioco in un altro fino ad arrivare ad un gioco finale che soddisfi le richieste fatte dall'utente. Questa tecnica \`e basata innanzi tutto su una 
particolare relazione di cui a breve si dar\`a una definizione. Prima di dare questa definizione \`e opportuno spiegare la notazione che sar\`a utilizzata da qui in poi. \\Di solito indicheremo con la lettera $t$ dei tempi d'esecuzione di processi. 
Se $A$ e $B$ sono due processi allora con la scrittura $A|B$ indichiamo un processo che \`e la composizione parallela di $A$ con $B$. Nella composizione parallela di due processi qusti possono procedere indipendentemente ma possono
anche interagire attraverso operazioni di input e output. In questo modo se si ha la composizione parallela di $A$ con $B$ allora un'operazione di output di $A$ pu\`o fornire l'input di un'operazione di input di $B$ e viceversa,
ottenendo quindi una comunicazione fra processi.
Con i simboli $C[\cdot]$ e $D[\cdot]$ si indicano dei contesti. 
Un contesto \`e un processo con un $buco$, ovvero un processo che ha come argomento un altro processo e va in esecuzione in parallelo a questo. Di solito un contesto \`e un attaccante che cerca di distinguere un processo che 
gli viene passato in input. Sia $C[\cdot]$ un contesto e siano $P$ e $Q$ dei processi, allora $C$ distingue i due processi se $C[P]$ (ovvero $C|P$) ha un comportamento diverso da $C[Q]$.
Infatti se quando $C$ interagisce con il processo $P$ osserva un comportamento diverso da quello che osserva quando interagisce con $Q$ allora $C$ pu\`o effettivamente distinguere i due processi.
Se $a$ \`e una qualsiasi stringa (supponiamo binaria per semplicit\`a) e $Q$ un processo, allora con la notazione $Pr[Q \rightsquigarrow a]$ si intende la probabilit\`a
che $Q$ abbia $a$ come output. \\
Se $Q$ \`e un processo e $\mathcal{E}$ \`e una sequenza ordinata di eventi allora con i simboli $Pr[Q \rightsquigarrow \mathcal{E}]$ si indica la probabilit\`a che $Q$ esegua la sequenza ordinata di eventi $\mathcal{E}$ . 
\begin{definizione}[Equivalenza Osservazionale Relativa alla Probabilit\`a $p$]
Siano $P$ e $Q$ due processi allora $P$ e $Q$ sono osservazionalmente equivalenti relativamente a $p$ (indicheremo la relazione con il simbolo $\approx_p$) se e solo se $\forall t, C, a, \mathcal{E}$
$\lvert Pr[C[P] \rightsquigarrow a] - Pr[C[Q]\rightsquigarrow a] \rvert \leq p(t)$ e $\lvert Pr[C[P] \rightsquigarrow \mathcal{E}] -  Pr[C[Q] \rightsquigarrow \mathcal{E}]\rvert \leq p(t)$ 
\end{definizione}
Questa definizione vuole catturare il concetto che due processi sono equivalenti a meno di una probabilit\`a $p$ se nessun avversario che ha tempo di esecuzione $t$ riesce
a distinguerli con una probabilit\`a maggiore di $p(t)$. Intendendo con $p(t)$ che la probabilit\`a \`e funzione del tempo d'esecuzione di chi cerca di distinguere. 
Si pu\`o dire che questa relazione sia un adattamento della nozione di equivalenza osservazionale (del modello formale) in modo che questa corrisponda all'indistinguibilit\`a 
del modello computazionale 
(questo nel momento in cui la probabilit\`a che permette ai due processi di essere in relazione \`e trascurabile). Se due processi sono legati da questa relazione d'equivalenza 
allora sono equivalenti a meno di una certa probabilit\`a nel senso che, 
qualsiasi attaccante (contesto) $C$ che va in esecuzione per un tempo $t$ ha una probabilit\`a di distinguere questi due processi al massimo $p(t)$.
Questa relazione d'equivalenza gode di alcune propriet\`a interessanti fra cui le seguenti:
\begin{enumerate}
 \item \emph{Se $P \approx_u Q$ e $Q \approx_{r} R$ allora $P \approx_{u+r} R$}
 \item \emph{Se $Q$ esegue un evento $\texttt{e}$ con probabilit\`a al massimo $p$ e $Q \approx_r S$ allora $S$ esegue l'evento $\texttt{e}$ con probabilit\`a al massimo $p+r$}
 \item \emph{Se $Q \approx_p S$ e $C$ si esegue in tempo $t_C$ allora $C[Q] \approx_{r} C[S]$ dove $r(t)=p(t+t_C)$}
\end{enumerate}

Quindi CryptoVerif, in generale, parte da una gioco $G_0$ che corrisponde ad un protocollo reale (di cui si vogliono provare delle propriet\`a) e costruisce una sequenza di giochi 
osservazionalmente equivalenti (secondo la definizione 2.1): $G_0 \approx_{p_1} G_1 \approx_{p_2} G_2 \dots \approx_{p_n} G_{p_{n}} $; data questa sequenza, 
attraverso le propriet\`a 1 e 2, conclude che $G_0  \approx_{\sum_{i=1}^{n}{p_i}}$ $G_{p_{n}} $, riuscendo cos\`i a dare un limite alla probabilit\`a che un attaccante riesca a distinguere
$G_0$ da $G_{p_{n}}$. Ora se in $G_{p_{n}}$ non esiste la possibilit\`a che un evento negativo possa accadere, visto che $G_0  \approx_{\sum_{i=1}^{n}{p_i}} G_{p_{n}} $, si pu\`o dare un limite superiore alla probabilit\`a che l'evento avvenga in $G_0$.
Questo limite \`e $\sum_{i=1}^{n}p_i$.\\Come \`e stato spiegato precedentemente le regole di trasformazione da un gioco ad un altro sono date mediante delle equivalenze. 
Dato un gioco $G$, per utilizzare una generica regola di trasformazione  $L \approx_p R$, CryptoVerif trova un contesto $C$ tale che $G \approx_0 C[L] $ semplicemente 
apportando delle modifiche sintattiche al gioco $G$, costruisce inoltre un gioco $G_s$ tale che $G_s \approx_0 C[R]$. CryptoVerif grazie alla Propriet\`a 3 pu\`o dedurre che $G \approx_p G_s$. 
Con questa tecnica CryptoVerif riesce a costruire catene
di giochi che permettono di provare delle propriet\`a di alcuni protocolli.
Le probabilit\`a utilizzate nelle sequenze di giochi create da CryptoVerif non sono trattate con la notazione asintotica, questo perch\'e
CryptoVerif adotta l'\emph{exact security framework} \cite{BellareR96}. Questo fatto permette al tool di calcolare in modo preciso le probabilit\`a, invece di 
considerare l'andamento di queste quando il parametro di sicurezza tende ad infinito.
Il fatto che CryptoVerif lavori nel modello esatto non significa che non possa darci risultati estendibili a probabilit\`a trascurabili.
Se per esempio alla fine di una prova CryptoVerif ha applicato $k$ volte un'equivalenza (con $k$ costante o valore polinomiale nel parametro di sicurezza) che vale a meno di una probabilit\`a $p$ allora
in output sar\`a reso noto il fatto che la catena di giochi vale a meno della probabilit\`a $kt$. Ora, se la probabilit\`a $t$ \`e noto essere
trascurabile, allora lo sar\`a anche $kt$ e quindi l'attaccante avr\`a una probabilit\`a trascurabile di distinguere il gioco finale da quello iniziale; 
altrimenti significa che l'attaccante ha una probabilit\`a non trascurabile pari esattamente a $kt$ di vincere il gioco iniziale e quindi
di distinguere questo dal gioco finale. 
Il calcolo di processi che CryptoVerif implementa \`e fondamentalmente quello che si trova in \cite{BlanchetJaggardScedrovTsayAsiaCCS08} con per\`o delle differenze.
Una fra le pi\`u importanti \`e appunto quella che CryptoVerif pu\`o trasformare un gioco in un altro quando questi appartengono ad una stessa classe d'equivalenza secondo la definizione 2.1, mentre 
nel calcolo sviluppato in \cite{BlanchetJaggardScedrovTsayAsiaCCS08} la definizione di relazione d'equivalenza su cui si basano le trasformazioni \`e diversa.
In \cite{BlanchetJaggardScedrovTsayAsiaCCS08} si considerano equivalenti giochi che sono distinguibili a meno di una probabilit\`a la cui unica peculiarit\`a \`e di essere trascurabile e nelle catene di giochi quindi la probabilit\`a di distnguere il gioco
iniziale da quello finale \`e ovviamente trascurabile\footnote{Si sa infatti che la somma di funzioni trascurabili rimane tale.}. In CryptoVerif invece si considerano i valori precisi delle probabilit\`a in funzione
di parametri dei giochi come per esempio numero di oracoli, lunghezza delle stringhe tempo d'esecuzione dell'attaccante ecc,ecc\dots Ecco quindi che CryptoVerif permette di calcolare in modo preciso le probablit\`a in 
gioco, senza che queste vengano inglobate (e quindi perse) nella notazione asintotica. 
L'utilit\`a principale di CryptoVerif \`e infatti quella di \emph{fare bene i conti} delle dimostrazioni basate su giochi. 

\section{Un Esempio: FDH}
\emph{Full Domain Hash} \`e uno schema di firma che segue il paradigma \emph{hash-and-sign}\footnote{Questo paradigma vuole che: dato un messaggio $m$ se ne ritorni 
la firma di $hash(m)$ e non la firma di $m$, dove la funzione hash pu\`o essere istanziata con qualsiasi funzione hash collision resistant. 
Si ottiene cos\`i una firma di lunghezza fissa e non dipendente dalla lunghezza del messaggio}. 
Quella che a breve seguir\`a \`e la descrizione dello schema di firma FDH nel linguaggio di CryptoVerif. In quest'esempio la funzione $f$ sar\`a la funzione la cui inversa
viene utilizzata per firmare messaggi, mentre la funzione $hash$ sar\`a la funzione utilizzata per ottenere il valore hash di una stringa di bit.\\
L'input fornito a CryptoVerif \`e costituito, fondamentalmente, da due parti: 
\begin{itemize}
 \item Un gioco iniziale $G_0$, in cui si modella la sicurezza dello schema.
 \item Alcune equivalenze necessarie a CryptoVerif per effettuare le modifiche ai giochi. 
\end{itemize}
La descrizione dello schema di firma FDH viene data al CryptoVerif attraverso il seguente gioco $G_0$:

\begin{verbatim}
foreach iH <= qH do   
  OH(x : bitstring) := return(hash(x)) |
  Ogen() := r <-R seed;     
    pk <- pkgen(r );    
    sk <- skgen(r );       
    return(pk ); (
    foreach iS <= qS do 
         OS(m : bitstring) := return(invf(sk , hash(m))) |
         OT (m1 : bitstring, s : D) := if f(pk , s) = hash(m1 ) then
             find u <= qS suchthat (defined(m[u]) && m1 = m[u]) then
                  end
             else
                  event forge
)         
\end{verbatim}

Quella che segue \`e una breve spiegazione di questo gioco.
Possiamo vedere come in questo gioco si forniscano $\texttt{qH}$ copie dell' oracolo $\texttt{OH}$ le quali ritornano il valore hash della stringa che gli si fornisce in input, ovvero $\texttt{x}$.\\
Abbiamo poi l'oracolo $\texttt{Ogen()}$ che ritorna al contesto una chiave pubblica dopo aver creato, partendo da un seme casuale, una coppia costituita da una chiave privata e una chiave pubblica.\\
Vengono fornite, mediante il costrutto $\texttt{foreach}$, $\texttt{qS}$ copie dell'oracolo $\texttt{OS}$ le quali si occupano di restituire in output una firma del messaggio che gli viene dato in input.
La firma di un messaggio $\texttt{m}$, data una chiave privata $\texttt{sk}$ mediante la funzione $\texttt{f}$, viene effettuata restituendo il valore $\texttt{invf(sk, m)}$.\\ 
Infine viene fornito un oracolo $\texttt{OT}$ che si occupa di verificare se la firma $\texttt{s}$ \`e valida per il messaggio $\texttt{m1}$. \\
In particolare se $\texttt{hash(m1)}$ $\neq$ $\texttt{f(pk, s)}$ allora la firma non \`e valida per il messaggio. Se invece $\texttt{hash(m1) = f(pk, s)}$,
l'oracolo si occupa di verificare se, per il messaggio $\texttt{m1}$, sia stata mai rilasciata una firma dall'oracolo $\texttt{OS}$. In caso affermativo il processo termina, altrimenti significa che 
l'attaccante, \`e stato in grado di forgiare una firma valida per il messaggio, e quindi \`e avvenuto l'evento \emph{forge}.\\
Notiamo come l'attaccante non sia modellato esplicitamente, infatti non possiamo fare nessuna assunzione sul comportamento di questo.
Possiamo immaginare un attaccante come un altro processo non meglio specificato messo in parallelo con questo gioco.\\ 
Per poter trasformare un gioco in un altro, CryptoVerif ha bisogno di alcune definizioni di primitive crittografiche da poter utilizzare.
\\
Le definizioni in CryptoVerif vengono fornite attraverso delle equivalenze che rappresentano regole di riscrittura sui processi e che possono valere a meno di una certa probabilit\`a.
Queste regole di riscrittura di un generico elemento \emph{L} in un generico elemento \emph{R}, possono essere valide incondizionatamente, 
oppure possono valere a meno di una certa probabilit\`a.
Nel secondo caso la riscrittura di un termine \emph{L} nell'equivalente \emph{R}, comporta l'introduzione di una differenza non nulla fra i due giochi.\\ 

Prima di descrivere la seconda parte dell'input di CryptoVerif, \`e necessario fare una piccola digressione riguardo al concetto di funzione \emph{one-way}.
Intuitivamente una funzione $f$ \`e one-way se non pu\`o essere invertita facilmente; cio\`e se, dato $y=f(x)$, \`e arduo riuscire a trovare un $x'$ tale che $f(x')=y$. 
Si noti come non sia necessario, per invertire la funzione, trovare $x$ ma \`e sufficiente trovare un $x'$ qualsiasi tale che $f(x')=y$.
\\Possiamo ora dare la seguente:
\begin{definizione}[Funzione One-Way]
Una funzione $f: \{0,1\}^*\rightarrow \{0,1\}^*$ \`e one-way se e solo se $\forall x \in  \{0,1\}^* \hbox{,} \forall A \in PPT$:  $\lvert Pr[A(f(x)) \in f^{-1}(f(x))]\rvert$ \`e una funzione 
trascurabile nell'input.
\end{definizione}

\`E importante notare come la definizione valga per ogni $x$ del dominio; con questo si vuole sottolineare che invertire $f$ deve essere \emph{sempre} difficile e non per particolari $x$.
\`E importante affermare ci\`o perch\'e tutta la crittografia moderna \`e fondata sull'ipotesi che esistano le funzioni one-way.
Si parla di ipotesi perch\'e non \`e stata ancora dimostrata l'esistenza di funzioni di questo genere\footnote{Questo non toglie
che esistano funzioni che si avvicinino all'idea che abbiamo di funzioni one-way, per esempio le funzioni hash SHA1, o MD5 oppure una funzione
$f$ che prende in input due primi $p$ e $q$ in base binaria e ne restituisce il prodotto.}.
La dimostrazione dell'esistenza di funzioni one-way comporterebbe, tra l'altro, anche la risoluzione della famosa questione riguardo agli insiemi
$P$ e $NP$\footnote{$P$ \`e l'insieme dei problemi risolvibili, nel caso pessimo, in un numero di passi polinomiale nell'input. $NP$ invece, \`e l'insieme dei problemi per cui dato un certo valore, 
si pu\`o verificare in tempo polinomiale se questo \`e o meno soluzione del problema (ovvero \`e l'insieme dei problemi con certificazione polinomiale). 
Non \`e ancora noto se questi insiemi siano o meno lo stesso insieme.}.
Il fatto che però qualcuno un giorno possa dimostrare che $P \neq NP$ non dimostrerebbe affatto l'esistenza delle funzioni one-way. 
Infatti una funzione one-way deve, come prima sottolineato, essere non invertibile in modo efficiente, sempre e non solo nel \emph{caso pessimo}. \\ 
Siamo ora pronti per vedere come il concetto di funzione one-way venga modellato in CryptoVerif.
Si tratta di dare una definzione di one-wayness per mezzo di un'equivalenza fra giochi.\\La definizione \`e la seguente:

\begin{verbatim}
equiv 
       foreach iK <= nK do r <-R seed; (
       Opk() := return(pkgen(r)) |
       foreach iF <= nF do x <-R D;
           (Oy() := return(f(pkgen(r), x)) |
            foreach i1 <= n1 do Oeq(x' : D) := return(x' = x) |
            Ox() := return(x)))
   
\end{verbatim}
\texttt{$\approx _{pow}$} 
\begin{verbatim}       
       foreach iK <= nK do r <-R seed; (
       Opk() := return(pkgen'(r)) |
       foreach iF <= nF do x <-R D;
          (Oy() := return(f'(pkgen'(r), x)) |
           foreach i1 <= n1 do Oeq(x':D) :=
                 if defined(k) then 
                     return(x' = x) 
                 else return(false) |
           Ox() := let k:bitstring = mark in return(x))).
 \end{verbatim}
Per ora, non \`e interessante per quale probabilit\`a questi giochi siano equivalenti, ecco perch\'e si \`e semplicemente indicato il valore della probabilit\`a con $pow$ pedice al simbolo $\approx$ 
senza specificare ulteriormente.

Questa equivalenza fra giochi cattura e definisce il concetto di funzione one-way. La funzione $\texttt{f}$ infatti, \`e one-way se e solo se vale l'equivalenza di cui sopra, 
e quindi il gioco a sinistra e quello a destra del simbolo \textbf{$\approx _{pow}$} sono indistinguibili.
Supponiamo infatti che la funzione $\texttt{f}$ non sia one-way, esister\`a dunque un avversario efficiente $A$ 
che pu\`o invertire $\texttt{f}$. $A$ sar\`a dunque in grado di distinguere i due membri dell'equivalenza $L \approx_{pow} R$. 
Questo perch\'e potendo invertire $\texttt{f}$, $A$ sar\`a in grado di osservare comportamenti diversi fra i giochi a seconda che $A$ chiami $\texttt{Oeq()}$ in $L$ o in $R$.
Procediamo con una sorta di esperimento mentale.\\ 
Supponiamo che $A$ chiami $\texttt{Oy()}$ ottenendo l'immagine di un valore mediante $\texttt{f}$, sia questa $y$; poich\'e $\texttt{f}$ non \`e one-way, 
$A$ inverte la funzione ottenendo un \verb!x'! tale che \verb!f(x')= y!.
Adesso $A$ non deve far altro che richiamare $\texttt{Oeq()}$ passando a questo come argomento \verb!x'!. Se $\texttt{Oeq()}$ \`e richiamato dal primo membro dell'equivalenza, 
allora $\texttt{Oeq()}$ ritorner\`a sempre true, mentre se appartiene al secondo ritorner\`a sempre false.\\
In questo modo $A$ osserva dei comportamenti diversi fra i due giochi, e quindi pu\`o distinguerli. 
Supponiamo, invece, che $\texttt{f}$ sia effettivamente one-way. Allora non esister\`a nessun attaccante efficiente che riesca ad invertire $\texttt{f}$.
L'unico modo che ha quindi un attaccante $A$ per invertire la funzione \`e chiamare $\texttt{Ox()}$ e ottenere cos\`i una preimmagine valida. 
Se però l'attaccante chiama $\texttt{Ox()}$ allora $L$ e $R$ sono effettivamente indistinguibili (a meno di una probabilit\`a trascurabile di cui parleremo dopo).
Notiamo infatti nella definizione dell'equivalenza che  $\texttt{Ox()}$\`e definito in maniera diversa in $L$ ed $R$.
In $L$, $\texttt{Ox()}$ si occupa semplicemente di ritornare il valore del dominio $\texttt{x}$, tale che $\texttt{f(x)=y}$. 
In $R$ invece, $\texttt{Ox()}$ prima di ritornare $\texttt{x}$, imposta al valore $\texttt{mark}$ la variabile $\texttt{k}$.
Ora, $\texttt{Oeq()}$ si comporter\`a in maniera diversa a seconda che sia richiamato da $L$ o da $R$.
Se infatti $\texttt{Oeq()}$ \`e chiamato da $L$, allora $\texttt{Oeq()}$ si proccuper\`a semplicemente di ritornare il valore booleano dell'espressione \verb!x'=x!.
Se invece,  $\texttt{Oeq()}$\`e chiamato da $L$ allora $\texttt{Oeq()}$ si comporter\`a in maniera differente a seconda che la variabile $\texttt{k}$ abbia o meno un valore 
(ovvero sia stata o meno definita da una precedente chiamata a $\texttt{Ox()}$). Se quindi $\texttt{k}$ \`e definita, allora $\texttt{Oeq()}$ si comporter\`a esattamente come si sarebbe comportato $\texttt{Oeq()}$  di $L$.
Se invece $\texttt{k}$ non \`e stata definita allora siginifica che l'attaccante non ha richiamato $\texttt{Ox()}$, quindi \`e lecito supporre che non sia riuscito ad invertire $\texttt{f}$ e quindi $\texttt{Oeq()}$ ritorna false.\\
\`E importante notare che l'attaccante avrebbe comunque la possibilit\`a di indovinare $\texttt{x}$ anche senza richiamare $\texttt{Ox()}$, ma questa \`e una probabilit\`a trascurabile per definizione di one-wayness. 
Di questa probabilit\`a viene comunque tenuto conto nell'equivalenza. L'equivalenza infatti, vale a meno di una certa probabilit\`a $pow$.
In questo modo i due giochi, sono effettivamente indistinguibili, perch\'e non presentano differenze di comportamento che $A$ possa notare, e quindi ai suoi occhi sono indistinguibili.
Quindi $L$ e $R$ sono indistinguibili \emph{se e solo se} $\texttt{f}$ \`e one-way e di conseguenza la precedente equivalenza \`e una definizione ben posta di funzione one-way.

Un'ulteriore definizione che viene fornita a CryptoVerif \`e quella di funzione hash. Questa definizione viene fornita al tool attraverso il seguente codice:
\begin{verbatim}
fun hash(hashinput):hashoutput.
equiv foreach iH <= nH do 
        OH(x:hashinput) := return(hash(x)) [all]
        <=(0)=>
      foreach iH <= nH do 
        OH(x:hashinput) :=
            find[unique] u <= nH suchthat defined(x[u],r[u]) && 
                    otheruses(r[u]) && x= x[u] then 
                        return(r[u]) 
            else 
               r <-R hashoutput; 
               return(r).
\end{verbatim}

La funzione hash \`e intesa implementata nel modello dell'oracolo random: se la funzione non \`e mai stata richiamata su un particolare valore $x_0$ allora viene restituito un valore casuale, 
altrimenti viene restituito lo stesso valore che era stato dato in output precedentemente. Questo viene fatto salvando il valore restituito per un particolare input in un array e poi,
al momento della chiamata, si effettua un lookup nell'array.
Infine abbiamo una semplice teoria equazionale per descrivere alcune propriet\`a delle funzioni in gioco.
Per esempio:
\begin{verbatim}
forall r:seed, x:D, x':D; (x' = invf(skgen(r),x)) = (f(pkgen(r),x') = x).
forall r:seed, x:D; f(pkgen(r), invf(skgen(r), x)) = x.
forall r:seed, x:D; invf(skgen(r), f(pkgen(r), x)) = x.
\end{verbatim}
Le precedenti regole servono a definire $\texttt{invf}$ come funzione inversa di $\texttt{f}$ e viceversa. Mentre le seguenti:
\begin{verbatim}
forall k:skey, x:D, x':D; (invf(k,x) = invf(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f(k,x) = f(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f'(k,x) = f'(k,x')) = (x = x).
\end{verbatim}\\
modellano l'iniettivit\`a delle funzioni $\texttt{invf}$, \verb!f'!, $\texttt{f}$\footnote{Non serve ai fini della dimostrazione modellare l'iniettivit\`a della funzione $\texttt{invf'}$. }.
In \cite{BlanchetPointchevalCrypto06} possiamo trovare una spiegazione delle fasi pi\`u importanti dell'output di CryptoVerif, e infine all'url \url{http://www.cryptoverif.ens.fr/FDH/fdh.pdf} troviamo l'ouput completo di CryptoVerif sull'input descritto precedentemente.

Nell'homepage di Blanchett si pu\`o trovare l'input completo in versione pdf, mentre in  \cite{BlanchetPointchevalCrypto06} si pu\`o 
trovare una spiegazione delle fasi pi\`u importanti dell'output di CryptoVerif, e infine 
all'url \url{http://www.cryptoverif.ens.fr/FDH/fdh.pdf} si ha l'ouput completo di CryptoVerif sull'input descritto precedentemente.

\chapter{Risultati Raggiunti}
Scopo principale di questo lavoro \`e la dimostrazione, mediante CryptoVerif, di un caso particolare di un risultato classico 
della crittografia computazionale. 
La dimostrazione proceder\`a utilizzando CryptoVerif per dimostrare il caso base 
di una prova che sar\`a, in generale, di tipo induttivo.
\section{Il Teorema}
Il risultato nella sua generalit\`a \`e il seguente:
\begin{teorema}
Se esiste un generatore pseudocasuale $\hat{G}:$ $\{0, 1\}^n \rightarrow \{0, 1\}^{n+1}$ (con fattore 
d'espansione $\hat{l}(n)=n+1$) allora per ogni polinomio $p(n)$ (tale che $\forall n$ $p(n)>n$)
esiste un generatore pseudocasuale $G$ con fattore d'espansione $l(n)=p(n)$.
\end{teorema}

Si pu\`o trovare una dimostrazione \emph{classica}\footnote{Per classica qui si intende \emph{non formale} nel senso informatico del termine.
Si intende cio\`e che il linguaggio con cui la dimostrazione \`e stata fatta utilizza anche un linguaggio che non \`e modellato
attraverso un sistema formale. La dimostrazione classica \`e scritta infatti in un linguaggio naturale.} di questo teorema in \cite{1206501}. 
La dimostrazione classica \`e di tipo costruttivo e procede in modo iterativo.
La costruzione inizia applicando il generatore pseudocasuale $\hat{G}$ ad un seme casuale $r$ di lunghezza $n$. 
$\hat{G}(r)$ sar\`a una stringa pseudocasuale di $n+1$ bit, di questi uno andr\`a a costituire parte dell'output finale mentre gli altri 
$n$ fungeranno da seme per una successiva applicazione di $\hat{G}$. 
\`E lecito utilizzare $n$ bit dell'output di $\hat{G}$ come successivo input di questo, infatti il risultato di $\hat{G}$ \`e 
una stringa pseudocasuale\footnote{E quindi anche una sua parte \`e pseudocasuale.} e quindi utilizzabile come seme di $\hat{G}$ tanto quanto 
lo \`e una stringa effettivamente casuale.
La dimostrazione procede poi estendendo questa iterazione ad un numero polinomiale di volte nel parametro di sicurezza e dimostrando, attraverso una tecnica \emph{ibrida},
che il risultato di questa iterazione \`e comunque una stringa pseudocasuale. Quella ibrida \`e una tecnica molto utilizzata per provare l'indistinguibilit\`a di due distribuzioni statistiche ed \`e 
la naturale applicazione del concetto di sequenza di giochi a distribuzioni statistiche.
La tecnica ibrida definisce una serie di distribuzioni che si situano fra due distribuzioni \emph{estreme} che sono quelle che si vogliono dimostrare essere indistinguibili.
In particolare, le distribuzioni estreme della dimostrazione sono la distribuzione $H_0$, definita dai possibili valori di $G(r)$ con 
$r$ estratto casualmente da $\{0,1\}^n$ e $H_{p(n)-n}$ definita dai valori di $w$ con $w$ scelto casualmente da $\{0, 1\}^{p(n)}$. 
Le distribuzioni situate fra $H_0$ e $H_{p(n)-n}$, sono le distribuzioni $H_j$ con $0<j<p(n)-n$, le quali sono definite dal valore di 
$G(r)$ con $r \in \{0, 1\}^{n+j}$. Ovvero la distribuzione j-esima \`e definita dal valore in output che il generatore pseudocasuale $G$ fornirebbe
se questo prendesse in input un valore appartenente a $\{0, 1\}^{n+j}$. Per la dimostrazione completa si consulti \cite{1206501}.

Alla fine dei calcoli viene provato che, se ci fosse una differenza sensibile fra le distribuzioni estreme, allora 
necessariamente, dovrebbe anche esserci una differenza
sensibile fra due distribuzioni vicine. Si prova infatti che, se $H_0$ \`e distinguibile in modo efficiente da $H_{p(n)-n}$, allora
dovrebbe esistere un $j$ ($0<j<p(n)-n$) tale che $H_j$ \`e distingubile da $H_{j+1}$.
Poich\'e quest'ultimo fatto sarebbe assurdo, perch\'e implicherebbe il fatto che $\hat{G}$ non \`e un generatore pseudocasuale, si
giunge al risultato desiderato, ovvero che le distribuzioni estreme sono indistinguibili. Quindi si giunge alla conclusione che $G$ 
\`e un generatore pseudocasuale.


Il risultato provato in questo lavoro \`e, come gi\`a detto, molto meno generale del teorema classico ed \`e enunciato nel seguente:
\begin{teorema}
Se esiste un generatore pseudocasuale $\hat{G}:$ $\{0, 1\}^n \rightarrow \{0, 1\}^{n+1}$ 
(con fattore d'espansione $\hat{l}(n)=n+1$) allora per ogni costante $k > 1$ esiste un generatore 
pseudocasuale $G$ con fattore d'espansione $l(n)=n+k$.
\end{teorema}

Si dimostrer\`a il teorema attraverso un procedimento induttivo che sfrutta CryptoVerif. 
In particolare la dimostrazione si articoler\`a in due fasi come ogni prova induttiva:
\begin{itemize}
 \item \emph{Caso Base.} Mediante CryptoVerif si dimostrer\`a il teorema per $k=2$.
 \item \emph{Caso Induttivo}. Si dimostrer\`a che CryptoVerif riesce a dimostrare il teorema per $k=i+1$ assumendo di essere riuscito a dimostrarlo per $k=i$.
\end{itemize}


Quando d'ora in poi si user\`a l'espressione \emph{essere riuscito a dimostrare} riferendoci a CrytoVerif, si intender\`a che CryptoVerif ha fornito una sequenza di giochi 
nell'ultimo della quale vale l'asserto che si desidera provare.

\newpage
\section{Dimostrazione del Caso Base}
Si cercher\`a ora di dimostrare il caso base del procedimento induttivo prima accennato. Ovvero si descriver\`a un file di input per CryptoVerif che permette a questo di provare che:
se esiste un generatore pseudocasuale $\hat{G}:$ $\{0, 1\}^n \rightarrow \{0, 1\}^{n+1}$ 
(con fattore d'espansione $\hat{l}(n)=n+1$) allora, per $k=2$, esiste un generatore 
pseudocasuale $G$ con fattore d'espansione $l(n)=n+k$.
L'input che \`e stato fornito a CryptoVerif inizia con le seguenti dichiarazioni:
\begin{verbatim}
1 type nbits 	 [fixed].     
2 type np1bits [fixed].   
3 type np2bits [fixed].   
\end{verbatim}
Alla linea 1 definiamo il tipo \emph{nbits} ovvero il tipo delle stringhe di lunghezza n. Questo tipo rappresenter\`a l'insieme $\{0, 1\}^n$. Alla linea 2 invece viene dichiarato un tipo
per rappresentare le stringhe appartenenti all'insieme $\{0, 1\}^{n+1}$, mentre alla riga 3 lo stesso viene fatto per le stringhe
appartenenti all'insieme $\{0, 1\}^{n+2}$. Si noti come ogni tipo sia dichiarato con il modificatore $\texttt{fixed}$ al fine di poter estrarre elementi casuali dai domini di quei tipi.
Con la linea di codice seguente:
\begin{verbatim}
5 param n1.
\end{verbatim}
Si dichiara un parametro $\texttt{n1}$. Questo parametro assumer\`a valori polinomiali nel parametro di sicurezza. 
Sar\`a utilizzato, principalmente, per fornire al distinguitore\footnote{L'attaccante modellato dal tool, in questo caso, 
cerca di distinguere l'output di $\texttt{G}$ da una stringa casuale.} un numero polinomiale di oracoli con cui interagire.
Quella che segue \`e una dichiarazione di un simbolo funzionale con i relativi tipi di input e di output.
\begin{verbatim}  
7 fun concatnp1(np1bits, bool):np2bits.
\end{verbatim}
La funzione prende in input una stringa di lunghezza $n+1$ e un bit, quest'ultimo rappresentato attraverso
un valore booleano. L'output sar\`a una stringa di lunghezza $n+2$.
Come si pu\`o intuire dal nome della funzione, questa rappresenta la concatenazione di una stringa di lunghezza $n+1$ con un bit.
Mediante la seguente equivalenza non facciamo altro che implementare la funzione dichiarata prima.
La funzione $\texttt{concatnp1}$ viene implementata mediante un'equivalenza che rappresenta il seguente asserto:
\emph{la concatenazione di una stringa casuale di $n+1$ bit con un bit casuale \`e una stringa casuale di
$n+2$ bit}. L'equivalenza \`e la seguente:
\begin{verbatim}
10 equiv
11       foreach i1<=n1 do
12             r <-R np1bits;
13             b <-R bool;
14             OGet():=return (concatnp1(r,b))
15       <=(0)=>
16      foreach i1 <=n1 do
17             w <-R np2bits;
18             OGet():=return(w).
\end{verbatim} 
In questo caso l'equivalenza non vale a meno di una probabilit\`a, ma sempre. Infatti \`e sempre vero che la concatenazione di una stringa casuale e di un bit casuale \`e una stringa casuale.
Con il seguente frammento di codice:
\begin{verbatim}
38 fun G'(nbits): np1bits.
39 equiv
40     foreach i1<=n1 do
41                 r <-R nbits;
42                 OGet():=return (G'(r))
43       <=(POW)=> 
44      foreach i1 <=n1 do
45                 x <-R np1bits;
46                 OGet():=return(x).
\end{verbatim}
per prima cosa si dichiara un simbolo funzionale $\texttt{G'}$ che sta per il $\hat{G}$ della dimostrazione classica. La dichiarazione viene, ovviamente, con i tipi di input e output del generatore pseudocasuale: linea 38.
Si noti come l'equivalenza valga a meno di una certa probabilit\`a. Infatti una stringa casuale \`e, in generale, di natura diversa da una stringa pseudocasuale sebbene siano distinguibili solo per una probabilit\`a trascurabile
che \`e rappresentata appunto da $\texttt{POW}$. La probabilit\`a $\texttt{POW}$ \`e la probabilit\`a che un attaccante efficiente 
riesca a distinguere una stringa casuale da una pseudocasuale. $\texttt{POW}$ \`e trascurabile per definizione di pseudocasualit\`a.
Con il seguente frammento di codice non facciamo altro che istruire CryptoVerif su cosa vogliamo che venga dimostrato.
\begin{verbatim}
query secret1 w.
\end{verbatim}
Il precedente frammento \`e lecito perch\'e ci\`o che si vuole \`e che il tool provi che la stringa $\texttt{w}$ sia indistinguibile da una stringa casuale. Nell'ultimo frammento di codice si vedr\`a come sia definita questa stringa.
L'ultimo frammento di codice rappresenta una sorta di $protocollo$ che funge da gioco iniziale:
\begin{verbatim}
50 process
51         G():=
52              r<-R nbits;
53              let x' = G'(r) in
54              let y' = getn(x') in
55              let b' = getlast(x') in
56              w:np2bits <-concatnp1(G'(y'), b');
57              return
\end{verbatim}
in questo gioco si applica due volte il generatore pseudocasuale $\texttt{G'}$. La prima volta alla stringa $\texttt{r}$ e la seconda al risultato fornito dalla prima applicazione di $\texttt{G'}$.
In particolare si noti come la variabile $\texttt{r}$ venga inizializzata con un valore casuale preso dall'insieme delle stringhe binarie di lunghezza $n$, e come
successivamente si proceda con l'assegnamento ad $\texttt{x'}$ della stringa pseudocasuale
$\texttt{G'(r)}$. Dopo questo passaggio, i primi $n$ bit della stringa $\texttt{x'}$ vengono estratti e assegnati alla variabile $\texttt{y'}$, mentre l'$n+1$-esimo bit viene assegnato alla variabile 
$\texttt{b'}$. Adesso \`e possibile utilizzare nuovamente $\texttt{G'}$ su input $\texttt{y'}$ e concatenare quindi $\texttt{G'(y')}$ con $\texttt{b'}$ ottenendo la stringa $\texttt{w}$.
$\texttt{w}$ quindi \`e il risultato di un duplice utilizzo del generatore pseudocasuale $\texttt{G'}$. Dimostrando la propriet\`a di one-session secrecy per la stringa $\texttt{w}$ CryptoVerif
non fa altro che dimostrare la pseudocasualit\`a di questa.
\newpage
  \subsection{I Giochi della Prova}
Il seguente \`e il gioco iniziale in cui si utilizza due volte il generatore pseudocasuale $\texttt{G'}$; 
la prima applicandolo ad un seme casuale $\texttt{r}$ e la seconda applicandolo a parte dell'output di $\texttt{G'(r)}$.
\begin{verbatim}
Game 1 is
O() :=
    r <-R nbits;
    x': np1bits <- G'(r);
    y': nbits <- getn(x');
    b': bool <- getlast(x');
    w: np2bits <- concatnp1(G'(y'), b');
    return()
\end{verbatim}
CryptoVerif prova ad applicare le equivalenze che gli sono state fornite e trova che pu\`o applicare solo la definizione di $\texttt{G'}$.
Si noti come CryptoVerif, nell'output mostrato qui sotto, cambi alcuni nomi. Per esempio $\texttt{i1}$ diventa $\texttt{i1\_5}$ nel membro sinistro dell'equivalenza e $\texttt{i1\_6}$ nel membro destro.
Questa ridenominazione avviene per evitare situazioni in cui si abbia uno stesso nome per due oggetti diversi. 
Si noti infine che l'equivalenza vale a meno della probabilit\`a $\texttt{POW}$. Questa probabilit\`a \`e asintoticamente trascurabile (per definizione di pseudocasualit\`a)
ma nel modello esatto se ne deve comunque tenere conto.
\begin{verbatim}
Applying equivalence
equiv foreach i1_5 <= n1 do 
              r <-R nbits; 
              OGet() := return(G'(r))
<=(set(proba <= POW))=>
      foreach i1_6 <= n1 do 
              x <-R np1bits; 
              OGet() := return(x)

[Excluding set(dist 1->2, proba <= POW)] yields
\end{verbatim}
Nel seguente gioco, ovvero il 2, viene inizializzata una nuova variabile $\texttt{x\_7}$ con un valore casuale dal dominio  $\texttt{np1bits}$, questa variabile viene poi assegnata a quella che prima
conteneva il risultato di $\texttt{G'(r)}$ e cio\`e $\texttt{x'}$.
\begin{verbatim} 
Game 2 is
O() :=
     x_7 <-R np1bits; 
     x': np1bits <- x_7;
     y': nbits <- getn(x');
     b': bool <- getlast(x');
     w: np2bits <- concatnp1(G'(y'), b');
     return()
\end{verbatim}
Nel gioco 2 c'\`e un assegnamento che \`e inutile ovvero quello che coinvolge la variabile $\texttt{x'}$; infatti si pu\`o eliminare  $\texttt{x'}$ e sostituirla con  $\texttt{x\_7}$. 
Il risultato di questa operazione lo si trova nel gioco 3:
\begin{verbatim} 
Applying remove assignments of useless yields

Game 3 is
O() :=
     x_7 <-R np1bits;
     y': nbits <- getn(x_7);
     b': bool <- getlast(x_7);
     w: np2bits <- concatnp1(G'(y'), b');
     return()
\end{verbatim}
Applicando ora la seguente equivalenza (che si ricordi vale sempre e non a meno di una probabilit\`a):
\begin{verbatim} 
Applying equivalence
equiv foreach i1_3 <= n1 do 
              r <-R np1bits; (
              OGetn() := return(getn(r)) |
              OGetlast() := return(getlast(r)))
<=(0)=>
      foreach i1_4 <= n1 do 
              x <-R nbits; 
              xl <-R bool; (
              OGetn() := return(x) |
              OGetlast() := return(xl))

yields
\end{verbatim}
\`e possibile modificare il gioco 3 nel seguente gioco, in cui le variabili $\texttt{xl\_9}$ e $\texttt{x\_8}$ sono inizializzate con dei valori casuali estratti rispettivamente dal dominio dei booleani e dal dominio
$\texttt{nbits}$ ovvero dalle stringhe di lunghezza $n$.
\begin{verbatim} 
Game 4 is
O() :=
     xl_9 <-R bool;
     x_8 <-R nbits;
     y': nbits <- x_8;
     b': bool <- xl_9;
     w: np2bits <- concatnp1(G'(y'), b');
     return()
\end{verbatim}
Si pu\`o vedere come anche nel gioco 4 si possano trovare degli assegnamenti inutili, ovvero quelli che coinvolgono le variabili $\texttt{y'}$ e $\texttt{b'}$. \`E possibile infatti eliminare queste variabili
sostituendo ogni occorrenza di queste con le variabili $\texttt{xl\_9}$ e $\texttt{x\_8}$. Effettuando queste modifiche si ottiene il seguente gioco:
\begin{verbatim} 
Applying remove assignments of useless yields

Game 5 is
O() :=
xl_9 <-R bool;
x_8 <-R nbits;
w: np2bits <- concatnp1(G'(x_8), xl_9);
return()
\end{verbatim}
Nel gioco 5 l'unica cosa che CryptoVerif pu\`o fare \`e quella di applicare nuovamente la definizione di $\texttt{G'}$:
\begin{verbatim}
Applying equivalence
equiv foreach i1_5 <= n1 do 
              r <-R nbits; 
              OGet() := return(G'(r))
<=(set(proba <= POW))=>
      foreach i1_6 <= n1 do 
              x <-R np1bits; 
              OGet() := return(x)
[Excluding set(dist 5->6, proba <= POW)] yields
\end{verbatim}
ottenendo il seguente gioco in cui sia $\texttt{xl\_9}$ che $\texttt{x\_10}$ 
sono stringhe casuali estratte rispettivamente dal dominio dei booleani e dal dominio delle stringhe di lunghezza $n+1$. 
Si ottiene quindi il gioco 6:
\begin{verbatim}
Game 6 is
O() :=
     xl_9 <-R bool;
     x_10 <-R np1bits;
     w: np2bits <- concatnp1(x_10, xl_9);
     return()
\end{verbatim}

\begin{verbatim} 
Applying equivalence
equiv foreach i1_1 <= n1 do 
       r <-R np1bits; 
       b <-R bool; 
       OGet() := return(concatnp1(r, b))
<=(0)=>
      foreach i1_2 <= n1 do 
      w <-R np2bits; 
      OGet() := return(w)
yields
\end{verbatim}
in questo gioco CryptoVerif non fa altro che applicare la definizione di $\texttt{concatnp1}$ che afferma che 
la concatenazione di una stringa casuale di $n$ bit e di un bit casuale \`e una stringa casuale di $n+2$ bit.
Otteniamo quindi il gioco finale, ovvero il gioco 7:
\begin{verbatim}
Game 7 is
O() :=
     w_11 <-R np2bits;
     w: np2bits <- w_11;
     return()
\end{verbatim}
In quest'ultimo gioco alla variabile $\texttt{w}$ \`e assegnato il valore di una stringa $\texttt{w\_11}$ 
che \`e scelta in maniera completamente casuale (con il costrutto $\texttt{<-R}$) dal dominio del tipo $\texttt{np2bits}$.
Di conseguenza la stringa $\texttt{w}$ \`e, in questo gioco, una variabile casuale a tutti gli effetti.
In questo gioco, quindi, l'attaccante non pu\`o distinguere la stringa $\texttt{w}$ da una stringa casuale perch\'e $\texttt{w}$ stessa \`e casuale. 
Di conseguenza, nel gioco finale, l'attaccante non pu\`o vincere.
CryptoVerif ha quindi dimostrato l'asserto iniziale, ovvero che dato un generatore pseudocasuale con fattore d'espansione $n+1$ se ne pu\`o ottenere uno con fattore d'espansione $n+2$.
Ecco che tutto ci\`o ci porta alla parte finale dell'output di CryptoVerif in cui questo ci dice per quali probabilit\`a vale la prova:
\begin{verbatim} 
RESULT Proved secrecy of w excluding 
set(dist 1->2, proba <= POW) U 
set(dist 5->6, proba <= POW)
RESULT Proved secrecy of w with probability 2. * POW
All queries proved.
\end{verbatim}
Siccome nella catena di giochi la definizione basata su equivalenza di $\texttt{G'}$ \`e stata applicata due volte \`e
ovvio che la catena di giochi sia valida a meno di $\texttt{2 * POW}$ dove $\texttt{POW}$ \`e la probabilit\`a
per cui vale la definizione di $\texttt{G'}$. Ovvio che per definizione $\texttt{POW}$ sia una probabilit\`a trascurabile, e quindi
anche $\texttt{2*POW}$, ma grazie a CryptoVerif non perdiamo di vista questo valore. CryptoVerif infatti ci dice
che la sequenza di giochi vale a meno di $\texttt{2*POW}$, e non, semplicemente, a meno di una probabilit\`a trascurabile.




\section{Il Passo Induttivo}
Quello che si cercher\`a di fare ora, \`e di provare che CryptoVerif riesce a dimostrare il teorema per $k=i+1$ sfruttando l'ipotesi 
che riesca a dimostrarlo per $k=i$.
Per poter dimostrare l'asserto per $k=i+1$ CryptoVerif, in generale, partir\`a da un file di input che contiene 
delle dichiarazioni e un gioco iniziale. \`E scontato che non avendo a disposizione infinito spazio, non si possa descrivere
un'infinit\`a di file di input (uno per ogni valore di $i$) per CryptoVerif; quindi, qui di seguito, si dar\`a uno schema generale della composizione di questi file. 
Prima di procedere \`e bene notare che nell'input le espressioni $i$ e $i+1$ stanno al posto degli effettivi valori di $i$. 
Cos\`i la dichiarazione del tipo $\texttt{type npibits}$ dovr\`a essere intesa come la dichiarazione di un tipo, nel cui nome, la lettera $i$ 
\`e stata sostituita con un particolare valore appartenente ai numeri naturali. I file dovranno avere:
\begin{enumerate}
 \item la dichiarazione $\texttt{type npbits [fixed].}$ Questo tipo si trova in ogni file di input per ogni $k$.
 \item $i+1$ dichiarazioni: \begin{itemize}
                                       \item $\texttt{type np1bits [fixed].}$ Questo tipo si trova in ogni file di input per ogni $k$.
                                       \item $\texttt{type np2bits [fixed].}$
				       \item \dots
				       \item \dots
				       \item $\texttt{type npibits [fixed].}$
				       \item $\texttt{type npi+1bits [fixed].}$	
	                               \end{itemize}
La lettera $i$ sar\`a sostituita dal particolare valore numerico che assume, stessa cosa per $i+1$.
Per esempio per $k=i+1=6$ si avr\`a: $\texttt{type np5bits [fixed].}$ e $\texttt{type np6bits [fixed].}$
\\
\\
\\
  \item $i$ dichiarazioni di simboli funzionali:\begin{itemize}
                                                          \item $\texttt{fun concatnp1(np1bits,bool):np2bits.}$
							  \item $\texttt{fun concatnp2(np2bits, bool):np3bits.}$
							  \item \dots
							  \item \dots
							  \item $\texttt{fun concatnpi(npibits, bool):npi+1bits.}$    
                                                         \end{itemize}
 
  \item  $i+1$ equivalenze del tipo:
				\begin{itemize}
				 \item \begin{verbatim}
equiv
     foreach i1<=n1 do
             r<-R npibits;
             b<-R bool;
             Oget():=return(concatnpi(r, b))
     <=(0)=>
      foreach i1<=n1 do
             w<-R npi+1bits;
             Oget():=return(w).
				\end{verbatim}
\end{itemize}
Anche in questa equivalenza $i$ va sostituita con il valore che questa assume.

\item i seguenti simboli funzionali:
      \begin{itemize}
       \item $\texttt{fun getn(np1bits):nbits.}$ Questo simbolo si trova in ogni file di input per ogni $k$.
       \item $\texttt{fun getlast(np1bits):bool.}$ Questo simbolo si trova in ogni file di input per ogni $k$.
      \end{itemize}		
\item la definizione dei simboli funzionali precedenti:
      \begin{itemize}
       \item \begin{verbatim}
         equiv
         foreach i1<=n1 do
               r <-R np1bits;(
               OGetn():=return (getn(r)) |
               OGetlast():=return (getlast(r)))
         <=(0)=>
        foreach i1 <=n1 do
                (
                OGetn():= x <-R nbits;return(x) |
                OGetlast():= xl <-R bool;return(xl)).
             \end{verbatim}
      \end{itemize}
\item la dichiarazione del generatore pseudocasuale con fattore d'espansione $n+1$. Questo simbolo si trova in ogni file di input per ogni $k$:
\begin{itemize}
 \item \begin{verbatim}
        fun G'(nbits): np1bits.
       \end{verbatim}
\end{itemize}
\item la definizione, mediante equivalenza, del generatore pseudocasuale con fattore d'espansione $n+1$:
\begin{itemize}
 \item \begin{verbatim}
      equiv
      foreach i1<=n1 do
                  r <-R nbits;
                  OGet():=return (G'(r))
        <=(POW)=> 
       foreach i1 <=n1 do
                  x <-R np1bits;
                  OGet():=return(x).
       \end{verbatim}
\end{itemize}

\item la clausola: $\texttt{query secret w.}$ Questa clausola si trova in ogni file di input per ogni $k$.
\item la definizione del protocollo iniziale. Descriviamo il protocollo iniziale mediante un gioco in cui si 
ottiene una stringa pseudocasuale di $n+i+1$ bit attraverso l'applicazione di $\texttt{G'}$ $i+1$ volte:



\begin{itemize}
 \item \begin{verbatim}
 process
        O():=
              r<-R nbits;
              let x1 = G'(r) in
              let y1 = getn(x1) in
              let b1 = getlast(x1) in
              let x2=G'(y1) in
              let y2=getn(x2) in
              let b2=getlast(x2) in
              ...
              ...
              ...
              let xi=G'(yi-1) in
              let yi=getn(xi-1) in
              let bi=getlast(xi-1) in
w:npi+1bits<-concatnpi(
            concatnpi-1(...concatnp1(G'(yi), b1), b2),... bi);
return()
\end{verbatim}
\end{itemize}
\end{enumerate}

Vediamo un esempio: se $k=i+1=4$, allora il file di input per provare l'asserto \`e il seguente:

\begin{verbatim}
  1 type nbits [fixed].      (* stringhe di lunghezza  n *)
  2 type np1bits [fixed].   (* stringhe di lunghezza  n+1 *)
  3 type np2bits [fixed].   (* stringhe di lunghezza  n+2 *)
  4 
  5 type np3bits [fixed].   (* stringhe di lunghezza  n+3 *)
  6 type np4bits [fixed].   (* stringhe di lunghezza  n+4 *)
  7 
  8 param n1.
  9 
 10 
 11 fun concatnp1(np1bits,bool):np2bits.
 12 fun concatnp2(np2bits, bool):np3bits.
 13 fun concatnp3(np3bits, bool):np4bits.
 14 
 15 (* La concatenzione di stringhe random è una stringa random*)
 16 equiv
 17       foreach i1<=n1 do
 18             r <-R np1bits;
 19             b <-R bool;
 20             OGet():=return (concatnp1(r,b))
 21       <=(0)=>
 22      foreach i1 <=n1 do
 23             w <-R np2bits;
 24             OGet():=return(w).
 25 
 26 equiv
 27     foreach i1<=n1 do
 28         r<-R np2bits;
 29         b2<-R bool;
 30         Oget():=return(concatnp2(r, b2))
 31         <=(0)=>
 32     foreach i1<=n1 do
 33         w<-R np3bits;
 34         Oget():=return(w).
 35 
 36 equiv
 37     foreach i1<=n1 do
 38         r<-R np3bits;
 39         b3<-R bool;
 40         Oget():=return (concatnp3(r, b3))
 41         <=(0)=>
 42     foreach i1<=n1 do
 43         w<-R np4bits;
 44         Oget():=return (w).
 45 
 46 
 47 
 48 
 49 (* Estrae i primi n bits da una stringa di n+1 bits *)
 50 fun getn(np1bits):nbits.
 51 (* Estrae l'ultimo bit da una stringa di n+1 bits *)
 52 fun getlast(np1bits):bool.
 53 equiv
 54        foreach i1<=n1 do
 55              r <-R np1bits;(
 56              OGetn():=return (getn(r)) |
 57              OGetlast():=return (getlast(r)))
 58        <=(0)=>
 59       foreach i1 <=n1 do
 60               (
 61               OGetn():= x <-R nbits;return(x) |
 62               OGetlast():= xl <-R bool;return(xl)
 63               ).
 64 proba POW.
 65 (* Generatore pseudocasuale con fattore n+1 *)
 66 fun G'(nbits): np1bits.
 67 equiv
 68     foreach i1<=n1 do
 69                 r <-R nbits;
 70                 OGet():=return (G'(r))
 71       <=(POW)=> (* da definire *)
 72      foreach i1 <=n1 do
 73                 x <-R np1bits;
 74                 OGet():=return(x).
 75 
 76 query secret w.
 77 
 78 process
 79         O():=
 80              r<-R nbits;
 81              let x1 = G'(r) in
 82              let y1 = getn(x1) in
 83              let b1 = getlast(x1) in
 84              let x2=G'(y1) in
 85              let y2=getn(x2) in
 86              let b2=getlast(x2) in
 87              let x3=G'(y2) in
 88              let y3=getn(x3) in
 89              let b3=getlast(x3) in
 90 w:np4bits <-concatnp3(concatnp2(concatnp1(G'(y3), b1), b2), b3);
 91 return()
\end{verbatim}

\subsection{L'Ipotesi Induttiva}
Si ricordi ancora una volta che l'espressione: \emph{per $k=i$ CryptoVerif riesce a dimostrare l'asserto}\footnote{Che \`e l'ipotesi induttiva che verr\`a sfruttata.}
significa che, per $k=i$ CryptoVerif partendo da un gioco iniziale\footnote{Che si pu\`o ottenere analizzando lo scheletro fornito 
precedentemente per $k=i+1$ ed applicandolo a $k=i$.} $G_0(i)$, descritto nel seguente frammento di codice:
\begin{verbatim}
O():=
  r<-R nbits;
  let x' = G'(r) in
  let y' = getn(x') in
  let b' = getlast(x') in
  let x''=G'(y') in
  let y''=getn(x'') in
  let b''=getlast(x'') in
  ...
  ...
  ...
w:npibits<-concatnpi-1(
            concatnpi-2(...concatnp1(G'(yi), b1), b2),... bi);
return()
\end{verbatim}
riesce a giungere al seguente gioco finale $G_n(i)$:
\begin{verbatim}
O():=
  w_i <-R npibits;
  w <- w_i;
return ();
\end{verbatim}
dove la stringa $\texttt{w}$ non pu\`o essere distinta da una stringa casuale.
Si noti che, proprio per costruzione dell'input, le istruzioni di $G_0(i)$ sono un sottoinsieme delle istruzioni del gioco iniziale per $k=i+1$, sia questo $G_0(i+1)$.
Infatti $G_0(i+1)$ ha il seguente aspetto:
\begin{verbatim}
O():=
  r<-R nbits;
  let x' = G'(r) in
  let y' = getn(x') in
  let b' = getlast(x') in
  let x''=G'(y') in
  let y''=getn(x'') in
  let b''=getlast(x'') in
  ...
  ...
  ...
w:npi+1bits<-concatnpi(
            concatnpi-1(...concatnp1(G'(yi), b1), b2),... bi);
return()
\end{verbatim}
Inoltre, sempre per costruzione, il file di input per $k=i+1$ avr\`a sempre un'equivalenza in pi\`u rispetto al file per $k=i$. Questa equivalenza \`e quella che serve a concatenare una stringa casuale di $n+i$ bit e un bit casuale, in una stringa
casuale di $n+i+1$ bit; si sta parlando dell'equivalenza relativa al simbolo funzionale $concatnpi$.
Quindi CryptoVerif, partendo da $G_0(i+1)$ e applicando le \emph{sole} regole di riscrittura relative a $k=i$ 
al sottoinsieme di istruzioni $G_0(i)$, \emph{per ipotesi induttiva}, riesce ad arrivare al gioco $G_{n-1}(i+1)$\footnote{Il penultimo della sequenza. 
Si vedr\`a infatti che con un'ultima applicazione di una regola si giunger\`a al gioco finale.}:
\begin{verbatim}
Game n-1 is
O() :=
xl <-R bool;
w_z <-R npibits;
w: npi+1bits <- concatnpi(w_z, xl);
return()
\end{verbatim}
in cui tutte le stringhe che, oltre ad appartenere al gioco $G_0(i+1)$, appartenevano anche a $G_0(i)$ sono confluite, 
grazie alle equivalenze relative a $k=i$, in $\texttt{w\_z}$. Si osservi, tra l'altro, che questo gioco, penultimo nella sequenza per $k=i+1$, 
\`e un sovrainsieme dell'ultimo gioco per $k=i$.
Ora, utilizzando la sola regola di riscrittura $concatnpi$, l'unica in pi\`u rispetto al file per $k=i$, 
CryptoVerif pu\`o passare al seguente gioco:
\begin{verbatim}
Game n is
O() :=
w_a <-R npi+1bits;
w: npi+1bits <- w_a
return()
\end{verbatim}
dove la variabile $\texttt{w}$ \`e effettivamente casuale, essendo essa estratta con il costrutto $\texttt{<-R}$ dal dominio a cui
appartiene.


Procediamo ora con una breve ricapitolazione di come la dimostrazione \`e avvenuta.
La dimostrazione \`e di tipo induttivo, di conseguenza si articola in due fasi: il caso base e il passo induttivo.
Per quanto riguarda il caso base si \`e scelto di mostrare come CryptoVerif dimostri l'asserto per $k=2$. Utilizzando qualsiasi altra costante 
$k > 1$ il risultato sarebbe stato ugualmente corretto, ma si avrebbe avuto a che fare con un file di input, e quindi una sequenza di giochi, di 
lunghezza necessariamente maggiore. Si noti che una dimostrazione per $k=1$ non avrebbe senso, infatti un generatore pseudocasuale con
fattore d'espansione $n+k=n+1$ \`e gi\`a in nostro possesso per ipotesi, visto che $\texttt{G'}$ accresce l'input casuale di un bit.
Una volta provato il caso base si procede con il caso induttivo.
Assumendo che CryptoVerif abbia gi\`a fornito una sequenza di giochi che prova che:
\begin{center}
\emph{$\forall i$ Se esiste un generatore pseudocasuale con fattore d'espansione $n+1$ allora 
esiste un generatore pseudocasuale con fattore d'espansione $n+i$}.
\end{center}

si dimostra che:
\begin{center}
\emph{$\forall i$ Se esiste un generatore pseudocasuale con fattore d'espansione $n+1$ allora 
esiste un generatore pseudocasuale con fattore d'espansione $n+i+1$}. 
\end{center}

L'ipotesi induttiva permette di assumere che esiste una sequenza di giochi che parte da un gioco iniziale, di cui si conosce la forma,
e arriva ad un gioco finale che deve necessariamente essere di una forma particolare (altrimenti non proverebbe l'asserto).
Si noti che per come i file di input sono costruiti, abbiamo che $\forall i$ $G_0(i) \subset G_0(i+1)$. 
Infine si nota che poich\'e per ipotesi induttiva CryptoVerif prova l'asserto per $k=i$, allora 
l'ultimo gioco della sequenza per $k=i$ deve necessariamente avere una stringa di $n+i$ bit estratta casualmente dal dominio $\texttt{npibits}$. 
Quindi partendo dal gioco $G_0(i+1)$, CryptoVerif applica tutte le equivalenze relative a $k=i$ e arriva
ad un gioco $G_{n-1}(i+1) \supset G_{n}(i)$. Applicando ora l'unica regola in pi\`u che il file di input relativo 
a $k=i+1$ ha rispetto al file per $k=i$, si giunge al gioco finale $G_n(i+1)$ in cui vale l'asserto, ovvero
si arriva ad un gioco in cui l'output di $\texttt{G}$ \`e effettivamente casuale.

\section{Limiti di CryptoVerif}
Il lettore potrebbe domandarsi perché non si sia cercato di provare il teorema 3.1 in tutta la sua generalit\`a e 
perch\'e, anche per provare un caso particolare del teorema, sia stato necessario utilizzare un procedimento induttivo.
\subsection{Definizione Iterativa}
Per quanto riguarda la prima parte della questione, la conclusione a cui si \`e giunti \`e che, fondamentalmente, il sistema di 
tipi di CryptoVerif non \`e abbastanza potente. La prima idea che si \`e cercato di implementare infatti, era di definire in 
maniera iterativa $\texttt{G}$ in funzione di $\texttt{G'}$. Si \`e tentato cio\`e di definire $\texttt{G}$ richiamando $\texttt{G'}$ 
un numero di volte pari ad un parametro dichiarato con la clausola $\texttt{param}$.
Si \`e per\`o riscontrato che i parametri, dichiarati con $\texttt{param}$ e che viaggiano su valori polinomiali nel parametro di sicurezza,
non sono fatti per essere utilizzati in questa maniera, ma per fornire un numero di oracoli pari al parametro, o ancora per
eseguire dei lookup su degli array grandi quanto il parametro.
Si potrebbe ancora obiettare che almeno per $k=2$ fosse possibile utilizzare una semplice regola di riscrittura che sfruttasse 
l'uso delle \emph{coppie}. Ovvero, si potrebbe pensare di definire $\texttt{G}$ mediante la seguente regola di riscrittura:
\begin{verbatim}
 forall x:nbits; G(x)=(G'(getn(G'(x))), getlast(G'(x))).
\end{verbatim}
In particolare quindi si definisce $\texttt{G}$ su input $\texttt{x
}$ $\in$ $\texttt{nbits}$ come una coppia che ha come primo elemento 
$\texttt{G'(getn(x))}$ e come secondo elemento $\texttt{getlast(G'(x))}$. I tipi che riguardano $\texttt{G'}$ sono corretti in quanto 
gli viene fornito in input sempre una stringa di lunghezza $n$. Il problema risiede in $\texttt{G}$, che deve essere dichiarato come una 
funzione che mappa stringhe di $n$ bit in stringhe di $n+2$ bit. \`E necessario definire $\texttt{G}$ cos\`i per essere fedeli 
alla definizione classica di generatore pseudocasuale.


Ma a causa di ci\`o, il problema si riduce al fatto che CryptoVerif non accetta un'equivalenza di tipo fra una coppia, costituita da una stringa
di $n+1$ bit e un singolo bit, e una stringa di $n+2$ bit. Di conseguenza CryptoVerif non accetta un input come quello sopra descritto,
affermando che il tipo di output di $\texttt{G}$ non \`e rispettato.
\subsection{Necessit\`a dell'Induzione}
\`E stato necessario dimostrare l'asserto in modo induttivo in quanto non \`e possibile mediante un unico file di input
dimostrare il teorema 3.2. Dimostrare senza induzione l'asserto comporterebbe l'analisi di un'infinit\`a di file di input, 
il che non \`e
ovviamente proponibile. Questo perch\'e, secondo la strada che si \`e cercato di seguire per dimostrare il teorema 3.2 per
un \emph{particolare} $k=i$, \`e necessario definire un file il cui contenuto
 \`e funzione del particolare valore di $i$; per esempio: un file di input per CryptoVerif
relativo a $k=i$, avr\`a $i+1$ definizioni $concatnpj$ con $0<j<=i+1$. Invece un file relativo ad un fattore d'espansione
pari a $i+1$ avr\`a un'equivalenza in pi\`u. Ecco quindi che non \`e possibile ottenere una sequenza di giochi che provi il teorema
3.2 per ogni numero naturale maggiore di zero. \`E per\`o naturale, come si \`e visto, procedere per induzione visto che
un file relativo ad un particolare valore di $i$ \`e molto simile ad un file per il valore $i+1$. 

\chapter{Conclusioni}
Questo lavoro \`e iniziato ponendosi come obiettivo quello di dimostrare in modo automatico un risultato che era gi\`a presente in
letteratura \cite{1206501}. Si \`e cercato di fornire, prima di tutto, le basi teoriche necessarie a capire concetti centrali
in questa tesi, come per esempio il concetto di casualit\`a e di generatore pseudocasuale. Dopo aver fornito le basi teoriche si
\`e ritenuto utile, ai fini della comprensione del terzo capitolo, dare una spiegazione del linguaggio che CryptoVerif implementa.
Infine, nell'ultimo capitolo, si \`e dimostrato automaticamente, un caso particolare di un famoso teorema
della crittografia computazionale. Si \`e infine cercato di spiegare il perch\'e non fosse possibile dimostrare direttamente,
ovvero con un unico file di input, il teorema in tutta la sua generalit\`a.

Durante lo svolgimento di questa tesi si sono rilevate alcune difficolt\`a. Come per esempio la 
quasi totale assenza di documentazione riguardo al tool utilizzato e all'analisi di protocolli crittografici nel modello computazionale
in generale. In effetti questo lavoro, oltre ad essere servito ad approfondire alcuni aspetti della sicurezza informatica
teorica, potrebbe in futuro servire come punto di partenza per iniziare ad usare il tool.
Questo lavoro, essendo una via di mezzo fra una tesi compilativa e una sperimentale, non \`e ovviamente completa e non lo sar\`a mai.
\`E interessante per\`o, far notare al lettore che esistono alcune direzioni in cui questo lavoro potrebbe essere esteso.
Per esempio potrebbe essere ampliato il sottoinsieme del linguaggio implementato da CryptoVerif che viene trattato nel capitolo due.
In questo lavoro infatti ci si \`e dedicati solamente ad una piccola parte del linguaggio di CryptoVerif, 
quella utile a capire come avviene la dimostrazione del teorema. 
Si potrebbe inoltre pensare di cercare di dimostrare altri risultati della crittografia computazionale. 
Si potrebbe per esempio verificare se CryptoVerif \`e in grado di provare un famoso teorema che lega l'esistenza delle funzioni 
one-way ai generatori pseudocasuali. Inoltre si potrebbe pensare di analizzare dei protocolli crittografici utilizzati 
quotidianamente che non siano gi\`a stati analizzati. In questo modo, si proverebbe o confuterebbe la sicurezza nel modello 
computazionale dei protocolli in questione; inoltre si contribuirebbe anche ad aumentare il numero di casi di studio disponibili per chi
volesse avvicinarsi a questo argomento. 
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\bibliographystyle{alpha}	
\bibliography{myrefs}		
\end{document}          
