type nbits [fixed].     (* stringhe di lunghezza  n *)
type np1bits [fixed].   (* stringhe di lunghezza  n+1 *)
type np2bits [fixed].   (* stringhe di lunghezza  n+2 *)

param n1.

(* La concatenazione di una stringa random di n+1 bits e un bit random è una stringa random di n+2 bits. *)
fun concatnp1(np1bits,bool):np2bits.

(* La concatenzione di stringhe random è una stringa random*)
equiv 
      foreach i1<=n1 do
            r <-R np1bits;
		    b <-R bool;
            OGet():=return (concatnp1(r,b))
      <=(0)=> 
     foreach i1 <=n1 do
            w <-R np2bits;
            OGet():=return(w).

(* Estrae i primi n bits da una stringa di n+1 bits *)
fun getn(np1bits):nbits.
(* Estrae l'ultimo bit da una stringa di n+1 bits *)
fun getlast(np1bits):bool.
equiv
       foreach i1<=n1 do
             r <-R np1bits;(
             OGetn():=return (getn(r)) |
             OGetlast():=return (getlast(r)))
       <=(0)=>
      foreach i1 <=n1 do
              (
              OGetn():= x <-R nbits;return(x) |
              OGetlast():= xl <-R bool;return(xl)
              ).
proba POW.
(* Generatore pseudorandom con fattore n+1 *)
fun G'(nbits): np1bits.
equiv
    foreach i1<=n1 do
            	r <-R nbits;
            	OGet():=return (G'(r))
      <=(POW)=> (* da definire *)
     foreach i1 <=n1 do
              	x <-R np1bits;
              	OGet():=return(x).

query secret w.

process
        O():=
             r<-R nbits;
             let x' = G'(r) in
             let y' = getn(x') in
             let b' = getlast(x') in
             w:np2bits <-concatnp1(G'(y'), b');
return()

