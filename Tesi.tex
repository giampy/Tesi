\documentclass[a4paper,openright,twoside,12pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs 
\usepackage{t1enc}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{array}
\usepackage{txfonts}

\author{Gian Pietro Farina}
\hyphenation{li-mi-ta-te li-mi-ta-ti e-qui-va-len-ti ov-via-men-te pse-u-do-ca-sua-le sem-bre-reb-be}

\newtheorem{definizione}{Definizione}[chapter]
\newtheorem{proposizione}{Proposizione}[chapter]
\pagenumbering{arabic}
\pagestyle{fancy}
% i comandi seguenti impediscono la scrittura in maiuscolo
% dei nomi dei capitoli e dei paragrafi nelle intestazioni
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
            % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
   \fancyhead{} % ignora, nello stile plain, le intestazioni
   \renewcommand{\headrulewidth}{0pt} % e la linea
}

\newcommand{\foreach}[2]{\textbf{foreach #1} $\leq$ \textbf{#2} \textbf{do}}
\newcommand{\return}[1]{\textbf{return}(#1);}
\renewcommand{\do}{\textbf{do}}
\newcommand{\pipe}{ \textbf{|} \\ \\}
\newcommand{\setR}[2]{#1 $\xleftarrow{R}$ #2;}
\newcommand{\set}[2]{#1 $\leftarrow$ #2;}
\newcommand{\ifthen}[2]{\textbf{if} #1 \textbf{then} #2}
\newcommand{\find}[6]{\textbf{find #1} $\leq$ \textbf{#2 suchthat} (\textbf{defined}(#3) $\wedge$ #4)) \textbf{then} #5 \\ \textbf{else} #6}
\newcommand{\event}{\textbf{event}}
\newcommand{\myend}{\textbf{end}}
\newcommand{\equiva}{\textbf{equiv}}
\begin{document}
\chapter*{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}
Negli anni anni '80 la crittografia ha cessato di essere un arte per assurgere allo stato di scienza. \\Come scienza, la crittografia moderna
si propone innanzi tutto di fornire definizioni rigorose dei concetti con cui ha a che fare (e.g. \emph{segretezza}) per poi apportare prove dei propri asserti basandosi 
su argomentazioni di carattere logico-matematico, ovvero di dimostrazioni. \\
Sebbene in alcuni casi sia possibile (ed \`e stato fatto, i.e ~\cite{Shannon}) provare dei risultati \emph{incondizionatamente} la maggior parte delle prove di teoremi nel campo 
della crittografia moderna sono basate su assunzioni che non sono ancora certe, ma che sono comunque ben formalizzate e inequivocabilmente descritte.\\La pi\`u importante \`e sicuramente
l'ipotesi dell'esistenza di funzioni \emph{one-way}. Tutte le prove che sono basate su assunzioni non verificate sono sempre e comunque valide, sia che le assunzioni fatte vengano dimostrate,
sia che vengano confutate; questo perch\`e ogni dimostrazione \`e del tipo: \emph{Se X allora Y} (e.g. se esiste una funzione one-way allora esiste un generatore pseudocasuale con fattore
d'espansione polinomiale). Semplicemente, nel caso in cui le assunzioni vengano confutate si renderebbero poco interessanti le dimostrazioni che si basano su queste\footnote{\`E ovvio che partendo da ipotesi false si possa
dimostrare qualsiasi cosa.}.
\`E per\`o giusto dire che le assunzioni che vengono fatte sono largamente ritenute vere; questo anche  grazie al fatto che alcune di esse si possono dedurre da altre ipotesi 
largamente ritenute vere sebbene non dimostrate.\\Lo studio di una congettura infatti, pu\`o fornire evidenti prove della sua validit\`a mostrando che essa \`e la tesi di un teorema che assume come ipotesi
un'altra congettura largamente ritenuta valida.
Da quando la crittografia si \`e guadagnata una validit\`a scientifica, sono nati almeno due modi profondamente diversi fra loro di
studiarla.\\In uno di questi, il modello \emph{formale}, le operazioni crittografiche sono rappresentate da espressioni simboliche, formali.
Nell'altro, il modello \emph{computazionale}, le operazioni crittografiche sono viste come funzioni su stringhe di bit che hanno una semantica probabilistica.
Il primo modello \`e stato ampiamente trattato in \cite{AbadiG99, BurrowsAN90, Kemmerer87, Paulson98}. 
Il secondo modello trova le basi in lavori di altrettanto illustri studiosi \cite{?}.\\
Il modello formale pu\`o contare su un vastissimo insieme di conoscenze teoriche derivanti da altri rami dell'informatica, in particolare la teoria dei linguaggi formali e della logica;
anche per questo il modello formale \`e stato sicuramente trattato in modo pi\`u approfondito, almeno fino ad ora. Questo ha fatto s\`i che lo stato dell'arte veda, per esempio, molti pi\`u tool di
verifica automatica che lavorano nel modello formale rispetto a tool che lavorano nel modello computazionale. 
Uno tra i pi\`u famosi tool che lavora nel modello formale \`e sicuramente il \emph{ProVerif}\footnote{Per informazioni pi\`u dettagliate su questo tool si visiti il seguente sito web: 
\url{http://www.proverif.ens.fr/}}.
I sostenitori del modello formale affermano che \`e molto conveniente ignorare i dettagli di una funzione crittografica e lavorare con una descrizione 
pi\`u di alto livello di questa, che non includa dettagli riguardanti la funzione crittografica. I sostenitori del modello crittografico computazionale invece, affermano che la visione
del modello formale non \`e molto realistica e che le funzioni crittografiche non devono essere viste come espressioni formali ma come algoritmi deterministici o probabilistici. Inoltre i
sostenitori del modello formale, trattando le primitive crittografiche come dei simboli impenetrabili, assumono implicitamente che siano corrette e inviolabili, cosa non esatta. D'altra parte il modello 
formale ha molti vantaggi come quello precedentemente accennato che riguarda la semplicit\`a con cui vengono costruiti strumenti automatici per la verifica di protocolli in questo modello.
Sembrerebbe quindi che esista un divario molto ampio fra i due modelli. In effetti cos\`i \`e, ma non sono mancati i tentativi di unificare i due modelli, o comunque di cercare una linea
di collegamento che li congiunga.
In \cite{DBLP:journals/joc/AbadiR07} gli autori cercano per la prima volta di porre le basi per iniziare a collegare questi due modelli.
In particolare il principale risultato di questo lavoro afferma che: se due espressioni nel modello formale sono equivalenti, una volta dotate di un'opportuna semantica probabilistica,
vengono mappati in \emph{ensemble} computazionalmente indistinguibili; quindi, sotto forti ma accettabili ipotesi\footnote{Un'importante ipotesi usata nella dimostrazione del risultato in questione
\`e che non devono esserci cicli crittografici, ovvero si considerano solo schemi crittografici in cui una chiave $k$, non \`e mai \emph{cifrata} attraverso $k$ stessa.}, 
l'equivalenza formale implica l'indistinguibilit\`a computazionale.
\`E quindi lecito affermare che un attaccante per il modello computazionale non \`e pi\`u potente di un attaccante nel modello formale. Questo risultato ha dato un'ulteriore spinta
ai sostenitori del modello formale che potevano cos\`i dimostrare risultati nel modello formale, con tutti i benefici che questo comportava, 
e estendere questo risultato al modello computazionale senza troppi problemi.
Un altra strada, invece, \`e quella che prevede di lavorare direttamente nel modello computazionale senza preoccuparsi di rispettare le forti ipotesi che erano 
state usate per dimostrare il risultato raggiunto in \cite{DBLP:journals/joc/AbadiR07}.
Rispetto al passato oggi giorno la crittografia non \`e utilizzata solo in ambiente militare, i suoi campi di utilizzo infatti, si estendono a molti aspetti della vita quotidiana.
Questo fatto ha comportato anche un'estensione dei possibili utilizzi della crittografia. Se infatti, un tempo l'unico scopo che si proponeva la crittografia era quello di garantire
la segretezza oggi giorno deve poter fornire molte altre garanzie fra le quali: autenticazione e integrit\`a dei messaggi scambiati fra due parti. Ecco quindi, che la nascita di queste esigenze
ha portato allo studio di schemi crittografici come per esempio \emph{message authentication code} oppure schemi crittografici asimmetrici.
Quando si parla di segretezza \`e importante come gia accennato dare prima una definizione di cosa si intende con questo termine.
Se per esempio si intende che nessun attaccante possa mai venire a conoscenza della chiave allora si ottiene qualcosa che non \`e quello che si vorrebbe. La segretezza riguarda un messaggio, 
la chiave \`e solo un mezzo che si utilizza per ottenere questo fine. 
Se invece si intende che un attaccante non riesca mai a scoprire il messaggio si \`e alla ricerca di una chimera. Innanzi tutto infatti, come si vedr\`a nel proseguo, dato abbastanza
tempo a disposizione si pu\`o sempre riuscire ad scoprire con \emph{certezza} il mesasggio; inoltre esiste sempre la possiblit\`a che un attaccante riesca ad indovinare il messaggio
semplicemente \emph{tirando ad indovinare}. Se infine si intende che ogni attaccante con determinate caratteristiche riesca difficilmente ad indovinare il messaggio cifrato, allora esiste la 
possibilit\`a di ottenere schemi che rispettano questo tipo di definizione.
Una tenica molto utilizzata per provare dei risultati nell'ambito dell crittografia computazionale \`e la cosidetta tecnica per riduzione. 
Le dimostrazioni di sicurezza basate su questa tecnica consistono nel mostrare che se esiste un aversario ch\`e pu\`o vincere con una probabilit\`a significativa e in un
tempo ragionevole allora anche un problema ben definito pu\`o essere risolto con una probabilit\`a significativa e in un tempo ragionevole. Ovviamente si cerca di ridurre
lo schema crittografico ad un problema che si sa bene essere difficile da risolvere.

\chapter{Il Modello Computazionale}
In questo capitolo si cercher\`a di descrivere le principali caratteristiche del modello computazionale. Saranno resi evidenti alcuni legami che
esistono fra la crittografia, la teoria della calcolabilit\`a e alcune nozioni di statistica e probababilit\`a. Sono questi infatti i cardini su cui poggia la crittografia
computazionale.\\ 
Si cercher\`a sempre di dare delle definizioni rigorose e il pi\`u possibile non ambigue. 
Si tenter\`a sempre, inoltre, di fornire delle dimostrazioni delle affermazioni che si fanno; \`e questo infatti il giusto modo di procedere.
Non \`e raro infatti, trovare esempi di schemi crittografici che sono stati ritenuti validi solo sulla base di argomentazioni approssimative e non formali e 
che non essendo stati dimostrati \emph{matematicamente} validi si sono poi rivelati tutt'altro che affidabili\footnote{Il cifrario di Vigener\`e ritenuto indecifrabile per 
moltissimi anni si può infatti violare facilmente con tecniche di tipo statistico.}.

\section{L'Avversario}
Il tipico avversario con cui si ha a che fare quando si studiano cifrari o protocolli crittografici nel modello computazionale,
è un avversario con risorse di calcolo \emph{limitate}. Limitate nel senso che si sceglie di porre un limite alla potenza di calcolo dell'avversario.
Questo significa che non avremo a che fare con un avversario che ha una capacit\`a di calcolo potenzialmente infinita o un tempo illimitato a disposizione.\\
Sebbene siano stati ideati cifrari sicuri anche rispetto ad avversari non limitati\footnote{Il cifrario \emph{one-time pad} \`e il tipico esempio di cifrario perfettamente sicuro o teoricamente sicuro.}, questi hanno alcuni difetti come per esempio
il fatto che la chiave debba essere lunga quanto il messaggio o che sia utilizzabile una sola volta.
Per rappresentare in modo formale un avversario con risorse di calcolo limitate, si pu\`o rappresentare questo come un generico algoritmo appartenente ad una 
particolare classe di complessit\`a computazionale\footnote{Un avversario infatti \`e una macchina di Turing che esegue un algoritmo.}. \\
Una linea di pensiero che accomuna ogni campo dell'informatica, considera efficienti gli algoritmi che terminano in un numero di passi polinomiale nella lunghezza dell'input, e inefficienti 
quelli che hanno una complessit\`a computazionale maggiore (e.g. esponenziale). 
La scelta di porre un limite alle risorse di calcolo dell'avversario \`e dettata dal buon senso.
\`E ragionevole infatti pensare che l'attaccante non sia infinitamente potente; \`e altrettanto ragionevole pensare che un attaccante non sia disposto ad impiegare un tempo \emph{eccessivo} per violare uno schema crittografico.\\
\`E logico quindi pensare che gli avversari vogliano essere \emph{efficienti}.\\
Pu\`o sembrare quindi naturale immaginare gli avversari come degli algoritmi che terminano in un numero polinomiale di passi
rispetto alla lunghezza dell'input. Come si pu\`o notare, non si fa alcuna assunzione particolare sul comportamento dell'avversario. Le uniche cose che sappiamo sono che:
\begin{itemize}
 \item l'avversario non conosce la chiave, ma conosce l'algoritmo di cifratura utilizzato  e i parametri di sicurezza, come per esempio la lunghezza della chiave\footnote{Il principio di Kerchoffs 
(famoso crittografo olandese, 19 Gennaio 1835 - 9 Agosto 1903) afferma che
l'algoritmo di cifratura non deve essere segreto e deve poter cadere nelle mani del nemico senza inconvenienti.}. 
 \item l'avversario vuole essere efficiente, ovvero polinomiale.
\end{itemize}

Non si fanno ipotesi sull'algoritmo che questo andr\`a ad eseguire.
Per esempio dato un messaggio cifrato $c=E_k(m)$, non ci aspettiamo che l'avversario non decida di utilizzare la stringa $c'$ tale che:  $c'=D_{k'}(E_k(m))$ con $k\neq k'$. 
Ovvero, sarebbe sbagliato supporre che l'avversario non cerchi di decifrare un messaggio mediante una chiave diversa 
da quella utilizzata per cifrarlo.
Nel modello computazionale i messaggi sono trattati come sequenze di bit e non come espressioni \emph{formali}; l'avversario, nel modello computazionale, pu\`o effettuare qualsiasi operazione su un messaggio. Questa visione \`e, a differenza di quella 
che si ha nel modello formale, sicuramente molto pi\`u realistica~\cite{DBLP:conf/crypto/2006}.\\

Non bisogna per\`o dimenticare che un avversario può sempre \emph{indovinare} il segreto che cerchiamo di nascondere o che cifriamo. 
Per esempio: se il segreto che si cerca di nascondere ha una lunghezza di $n$ bit, l'avversario pu\`o sempre effettuare una scelta casuale fra il valore 0 e il valore 1 per $n$ volte.
La probabilit\`a che l'avversario ottenga una stringa uguale al segreto \`e ovviamente di $\frac{1}{2^n}$. 
Questa probabilit\`a tende a 0 in modo esponenziale al crescere della lunghezza del segreto, ma per valori finiti di $n$ questa probabilit\`a non sar\`a mai 0.
\`E quindi pi\`u realistico cercare di rappresentare l'avversario come un algoritmo che, oltre a terminare in tempo polinomiale, ha
anche la possibilit\`a di effettuare scelte casuali e di commettere errori (anche se con probabilit\`a limitata).
La classe dei problemi risolti da questo tipo di algoritmi \`e indicata con la
sigla \emph{BPP} (i.e. \emph{Bounded-Probability Polynomial Time}).\\Un modo pi\`u formale di vedere questo tipo di algoritmi \`e il seguente: si suppone che la macchina di Turing che 
esegue l'algoritmo, oltre a ricevere l'input, diciamo $x$, riceva anche un input ausiliario $r$. Questa stringa di bit $r$, rappresenta una possibile sequenza di lanci di moneta dove \`e stato associato al valore $0$ la croce e al valore $1$ la testa (o anche viceversa ovviamente).
Qualora la macchina dovesse effettuare una scelta casuale, non dovr\`a far altro che prendere il successivo bit dalla stringa $r$, e prendere una decisione in base ad esso
(\`e, in effetti, come se avesse preso una decisione lanciando una moneta). Ecco quindi che il nostro tipico avversario si configura come un algoritmo polinomiale probabilistico.
\`E inoltre giustificato cercare di rendere sicuri\footnote{In qualsiasi modo si possa intendere il concetto di sicurezza. Vedremo che in seguito si daranno delle definizioni rigorose di questo concetto.} gli schemi crittografici rispetto, principalmente, a questo tipo di avversario.
Non \`e quindi necessario dimostrare che un particolare schema crittografico sia inviolabile, ma basta dimostrare che:
\begin{itemize}
 \item in tempi ragionevoli lo si pu\`o violare solo con scarsissima probabilit\`a.
 \item lo si pu\`o violare con alta probabilit\`a, ma solo in tempi non ragionevoli.
\end{itemize}
Sappiamo che il concetto di \emph{tempo ragionevole} \`e catturato dalla classe degli algoritmi polinomiali probabilistici. Vediamo ora di catturare il concetto di \emph{scarsa probabilit\`a}.
\section{Funzioni Trascurabili e non $\dots$}
In crittografia i concetti di \emph{scarsa probabilit\`a} e di evento \emph{raro} vengono formalizzati attraverso la nozione di funzione trascurabile.
\begin{definizione}{Funzione Trascurabile.}
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e trascurabile se e solo se per ogni polinomio $p$, esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) < \frac{1}{p(n)}$.  
\end{definizione}
Una funzione trascurabile, quindi, \`e una funzione che tende a 0 pi\`u velocemente dell'inverso di qualsiasi polinomio.
Un'altra definizione utile \`e la seguente:
\begin{definizione}{Funzione Distinguibile.}
Sia $\mu: \mathbb{N} \rightarrow \mathbb{R^{+}}$ una funzione. Si dice che $\mu$ \`e distinguibile se e solo se esiste un polinomio $p$, tale per cui esiste $C \in \mathbb{N} $ tale che $\forall n>C$: $\mu(n) > \frac{1}{p(n)}$.  
\end{definizione}
Per esempio la funzione $n  \mapsto 2^{-\sqrt{n}}$ \`e una funzione trascurabile, mentre la funzione $n \mapsto \frac{1}{n^2}$ non lo \`e. 
Ovviamente esistono anche funzioni che non sono n\'e trascurabili n\'e distinguibili. Per esempio, la seguente funzione definita per casi:\\
$f(n) = \begin{cases} 1, & \mbox{se } n\mbox{ \`e pari} \\ 0, & \mbox{se } n\mbox{ \`e dispari} \end{cases}$\\
non \`e n\'e trascurabile n\'e distinguibile. Questo perch\'e le definizioni precedenti, pur essendo molto legate, non sono l'una la negazione dell'altra.

Se sappiamo che, in un esperimento, un evento avviene con una probabilt\`a trascurabile,
quest'evento si verificher\`a con una probabilit\`a trascurabile anche se l'esperimento viene ripetuto molte volte (ma sempre un numero polinomiale di volte), e quindi per la legge dei grandi numeri, 
con una frequenza anch'essa trascurabile\footnote{In modo informale, la legge debole dei grandi numeri afferma che: per un numero grande di prove, 
la frequenza approssima la probabilit\`a di un evento.}. 
Le funzioni trascurabili, infatti, godono di due particolari propriet\`a di chiusura, enunciate nella seguente:
\begin{proposizione}
Siano $\mu_1, \mu_2$ due funzioni trascurabili e sia $p$ un polinomio. Se $\mu_3 = \mu_1 + \mu_2$, e $\mu_4= p\cdot \mu_1$, allora $\mu_3$, $\mu_4$ sono funzioni trascurabili.  
\end{proposizione} 

Se quindi, in un esperimento, un evento avviene solo con probabilit\`a trascurabile, ci aspettiamo che, anche se ripetiamo l'esperimento un numero polinomiale di volte, questa probabilit\`a
rimanga comunque trascurabile.\\
Per esempio: supponiamo di avere un dado truccato in modo che la probabilit\`a di ottenere 1 sia trascurabile. Allora se lanciamo il dado un numero polinomiale di volte, la probabilit\`a
che esca 1 rimane comunque trascurabile.\\
\`E ora importantissimo notare che:
\textbf{gli eventi che avvengono con una probabilit\`a trascurabile possono essere ignorati per fini pratici}.
In \cite{1206501}, infatti leggiamo:
\begin{quotation}
\emph{Events that occur with negligible probability are so unlikely to occur that can be ignored for all practical purposes. Therefore,
a break of a cryptographic scheme that occurs with negligible probability is not significant.}
\end{quotation}
Potrebbe sembrare pericoloso utilizzare degli schemi crittografici che ammettono di essere violati con probabilit\`a trascurabile, ma questa possibilit\`a \`e cos\`i remota, che una tale preoccupazione \`e da ritenersi
ingiustificata.
Finora abbiamo parlato di funzioni che prendono in input un argomento non meglio specificato. 
Al crescere di questo parametro, le funzioni si comportano in modo diverso, a seconda che siano trascurabili, oppure no.
Ma cosa rappresenta nella realt\`a questo input?
Di solito, questo valore rappresenta un generico parametro di sicurezza, indipendente dal segreto. \`E comune immaginarlo come la lunghezza in bit delle chiavi.\\
D'ora in poi con affermazioni del tipo \flqq\l'algoritmo \`e polinomiale, o esponenziale\frqq, si intenderanno algoritmi polinomiali o esponenziali nella lunghezza (in bit) del parametro di sicurezza (indicato con $n$). Si utilizzer\`a questa assunzione anche quando si faranno affermazioni su funzioni trascurabili o meno. Quelle funzioni saranno trascurabili o meno nel parametro $n$.
Tutte le definizioni di sicurezza che vengono date nel modello computazionale e che utilizzano le probabilit\`a trascurabili, sono di tipo \emph{asintotico}.
Un template di definizione di sicurezza è il seguente \cite{1206501}:
\begin{quotation}
\emph{A scheme is secure if for every probablistic polynomial-time adversary \textbf{A} [...], the probability that \textbf{A} succeds in this attack [...]
is negligible}
\end{quotation}
Essendo questo schema di definizione asintotico (nel parametro di sicurezza \emph{n}), \`e ovvio che non considera valori piccoli di \emph{n}.
Quindi se si dimostra che un particolare schema crittografico \`e sicuro secondo una definizione di questo tipo, pu\`o benissimo capitare che per valori piccoli di \emph{n} lo schema
sia violabile con alta probabilit\`a e in tempi ragionevoli.
\section{Indistinguibilit\`a Computazionale}
Se due oggetti, sebbene profondamente diversi fra loro, non possono essere distinti, allora sono, da un certo punto di vista, equivalenti.
Nel caso della crittografia computazionale, due oggetti sono computazionalmente equivalenti se nessun algoritmo efficiente li pu\`o distinguere.
Possiamo immaginare che un algoritmo riesca a distinguere due oggetti, se quando gli si da in input il primo, lui da in output una costante \emph{c}, mentre se gli si 
fornisce come input il secondo da in output una costante \emph{$c'$} e ovviamente $c \neq c'$.
La definizione tipica di indistinguibilit\`a computazionale \`e data prendendo come oggetti da distinguere alcune particolari distribuzioni statistiche detti \emph{ensembles}.

\begin{definizione}{Ensemble.}
Sia $I$ un insieme numerabile infinito. $X=\{X_i\}_{i \in I}$ \`e un ensemble su $I$ se e solo se \`e una sequenza di variabili statistiche, tutte con lo stesso tipo di distribuzione.
\end{definizione}
Un \emph{ensemble} \`e quindi una sequenza infinita di distribuzioni di probabilit\`a\footnote{Siccome si parla di distribuzioni su stringhe di bit con lunghezza finita,
in crittografia computazionale si considerano ensemble che sono una sequenza infinta di distribuzioni finite di stringhe di bit.}. 
Tipicamente le variabili dell'ensemble sono stringhe di lunghezza $i$. $X_i$ \`e quindi una distribuzione di probabilit\`a su stringhe di lunghezza $i$.

Ora supponiamo di avere due ensemble $X$ e $Y$. Intuitivamente queste distribuzioni sono indistinguibili se nessun algoritmo (efficiente) pu\`o accettare infiniti elementi di $X_n$
(per esempio stampando $1$ su input preso da $X_n$) e scartare infiniti elementi di $Y_n$ (per esempio stampare $0$ su input preso da $Y_n$). \`E importante notare che sarebbe facile 
distinguere due \emph{singole} distribuzioni usando un approccio esaustivo, ecco perch\'e si considerano sequenze infinite di distribuzioni finite.
In poche parole questi ensemble sono indistinguibili se ogni algoritmo (efficiente) accetta $x \in X_n$ se e solo se accetta $y \in Y_n$. Ovviamente il \emph{se e solo se} non pu\`o e non deve
essere inteso in senso \emph{classico}, ma deve essere inteso in senso statistico. Poich\'e in crittografia si \`e soliti indicare con $U_m$ una variabile
uniformemente distribuita sull'insieme delle stringhe di lunghezza $m$, chiameremo $U=\{U_n\}_{n \in \mathbb{N}}$ l'ensemble uniforme.
Dopo questa breve introduzione all'indistinguibilit\`a siamo pronti per dare una definizione rigorosa:

\begin{definizione}{Indistinguibilit\`a computazionale.}
Due ensemble $X=\{X_n\}$, $Y=\{Y_n\}$ sono computazionalmente indistinguibili se e solo se per ogni algoritmo $D \in BPP$ (detto distinguitore) esiste $\mu$ trascurabile tale che:
\begin{center}$\lvert Pr[D(1^n, X_n) = 1] - Pr[D(1^n, Y_n) = 1] \rvert \leq \mu(n)$.\end{center}
\end{definizione}
Nella definizione precedente: $Pr[D(1^n, X_n) = 1]$ \`e la probabilit\`a che, scegliendo $x$ secondo la distribuzione $X_n$ e fornendo questo valore al distinguitore insieme al valore $1^n$, il distinguitore stampi $1$.
Il fatto che al distinguitore si fornisca anche il valore del parametro di sicurezza in base unaria, serve ad esser sicuri che in ogni caso il distinguitore impieghi un tempo polinomiale 
nel parametro di sicurezza.
Infatti, il distinguitore quando si trover\`a a dover leggere il primo parametro, necessariamente impiegher\`a un tempo polinomiale nel parametro di sicurezza, visto che questo \`e stato 
fornito in base unaria\footnote{Ignoreremo, d'ora in poi, questo cavillo formale.}.

La definizione di indistinguibilit\`a computazionale cattura quindi il seguente concetto: se due ensemble sono computazionalmente indistinguibili, 
allora la probababilit\`a che un distinguitore riesca a discernere i valori provenienti da un insieme rispetto all'altro \`e trascurabile; di conseguenza agli occhi del distinguitore 
gli ensemble non sono differenti e quindi sono per lui equivalenti (o meglio computazionalmente equivalenti o ancora, indistinguibili in tempo polinomiale). 
Non \`e raro, nell'ambito scientifico in particolare, basarsi sul concetto generale di indistinguibilit\`a al fine di creare nuove classi di equivalenza di oggetti.
\begin{quotation}
\emph{The concept of efficient computation leads naturally to a new kind of equivalence between objects: Objects are considered to be computationally equivalent if they cannot be
differentiated by any efficient procedure. We note that considering indistinguishable objects as equivalent is one of the basics paradigms of both science and real-life situations. Hence,
we believe that the notion of computational indistinguishability is a very natural one~\cite{519078}.}
\end{quotation}


\section{Pseudocasualit\`a e Generatori Pseudocasuali}
Argomento centrale di questa sezione \`e il concetto di \emph{pseudocasualit\`a} applicato a stringhe di bit di lunghezza finita.
Parlare di pseudocasualit\`a applicata ad una \emph{singola} stringa, ha poco senso quanto ne ha poco parlare di singola stringa casuale.
Il concetto di casualit\`a (come quello di pseudocasualit\`a) si applica, infatti, a distribuzioni di oggetti (stringhe di bit nel nostro caso) e non a singoli oggetti.\\
La nozione di casualit\`a \`e fortemente legata a quella di distribuzione uniforme. Un insieme di oggetti \`e caratterizzato
da una distribuzione uniforme se la probabilit\`a \`e equamente distribuita su tutti gli oggetti. Quindi \emph{l'estrazione} di un elemento \`e del tutto casuale, 
perch\'e non ci sono elementi pi\`u probabili di altri.

Il concetto di pseudocasualit\`a \`e un caso particolare di indistinguibilit\`a, infatti una distribuzione \`e \emph{pseudocasuale} se nessuna procedura efficiente, 
pu\`o distinguerla dalla distribuzione uniforme.
\begin{definizione}{Pseudocasualit\`a.}
L'ensemble $X=\{X_n\}_{n \in \mathbb{N}}$ \`e detto pseudocasuale se e solo se $ \exists l:$ $\mathbb{N}\rightarrow\mathbb{N}$ tale che: 
$X$ \`e computazionalmente indistinguibile da $U=\{U_{l(n)}\}_{n \in \mathbb{N}} $.  
\end{definizione}
Data questa definizione, possiamo finalmente definire formalmente cosa sia un generatore pseudocasuale.
\begin{definizione}{Generatore Pseudocasuale.}
Sia $l:$ $\mathbb{N}\rightarrow\mathbb{N}$ un polinomio detto fattore d'espansione. 
Sia G un algoritmo polinomiale deterministico tale che: $\forall s \in \{0, 1\}^{n}$ $G(s) \in \{0, 1\}^{l(n)}.$
Allora $G$ \`e un generatore pseudocasuale se e solo se valgono le seguenti condizioni:
\begin{itemize}
 \item Espansione: $\forall n: l(n) > n$
 \item Pseudocasualit\`a: $\forall D \in BPP, \exists \mu$ trascurabile tale che \begin{center}
                                                   $\lvert Pr[D(r) = 1] - Pr[D(G(s)) = 1]\rvert$                               
                                                                                 \end{center} 
con $r \in U_{l(n)}$ e $s \in U_{n}$
\end{itemize}
\end{definizione}

Quindi: se data una stringa di bit $s \in U_{n}$, nessun distinguitore efficiente riesce a distinguere (con una probabilit\`a non trascurabile) $G(s)$ da una stringa $r \in U_{l(n)}$, allora 
$G$ \`e un generatore pseudocasuale. Il suo output, infatti, non \`e distinguibile dalla distribuzione effettivamente uniforme.

\`E importante per\`o notare, che la distribuzione di stringhe in output di un generatore pseudocasuale \`e fortemente differente dalla distribuzione effettivamente casuale. Per rendere pi\`u chiara questa distinzione procederemo
con un importante esempio.
Supponiamo di avere un generatore pseudocasuale \emph{G} con fattore d'espansione $l(n)=2n$.
L'insieme $A=\{0, 1\}^{2n}$ ha, ovviamente, una cardinalit\`a pari a $2^{2n}$. Fissando quindi una certa stringa $x \in A$, 
questa ha una probabilit\`a di esser scelta in maniera casuale pari a: $\frac{1}{\lvert A \rvert} = \frac{1}{2^{2n}}$.

Ragioniamo adesso sull'output del generatore $G$. Questo prende un input appartenente al dominio: $B=\{0, 1\}^{n}$. 
Anche considerando il caso \emph{migliore} di un generatore iniettivo\footnote{Una generica funzione $f$ \`e iniettiva se e solo se $\forall x_1, x_2:$ $x_1 \neq x_2 \Rightarrow f(x_1) \neq f(x_2)$.},
il codominio di $G$ avr\`a una cardinalit\`a pari a quella del dominio ovvero $2^{n}$. La maggior parte degli elementi dell'insieme $A$ non ricadr\`a 
nell'output di $G$; questo a causa dell'abissale differenza di cardinalit\`a fra gli insiemi $G(B)$ e $A$.
Quindi la probabilit\`a che una stringa scelta in maniera uniforme dall'insieme $A$ ricada nel codominio di $G$ \`e di $\frac{2^{n}}{2^{2n}}$, cio\`e $2^{-n}$.
In teoria, quindi, \`e facile immaginare un distinguitore $D$ che riesca a discernere l'output di $G$ dalla distribuzione uniforme con probabilit\`a non trascurabile.
Supponiamo che $D$ prenda in input $y \in A$. Tutto ci\`o che $D$ deve fare \`e ricercare in modo esaustivo un $w \in B$ tale che $G(w) = y$.
Se $y \in G(B)$ allora $D$ se ne accorger\`a con probabilit\`a 1, mentre se $y$ \`e stato scelto in maniera uniforme dall'insieme $A$, $D$ stamper\`a 1 con probabilit\`a $2^{-n}$. 
\newpage Quindi abbiamo che:
\begin{center}
$\lvert Pr[D(r)=1] - Pr[D(G(s))=1]\rvert \geq 1 - 2^{-n}$
\end{center} 
con $r \xleftarrow{R} A$ e $s \xleftarrow{R} B$~\footnote{Con la notazione $s \xleftarrow{R} O$, si intende la scelta dell'elemento 
$s \in O$ in maniera casuale.}.\\
Il membro a destra della disequazione \`e una funzione distinguibile. Sembrerebbe quindi che $G$ non sia un generatore pseudocasuale.
C'\`e un' importante constatazione da fare per\`o. Il distinguitore $D$ non \`e efficiente! Infatti impiega un tempo esponenziale nel parametro $n$, e non polinomiale.
La distribuzione generata da $G$ dunque, \`e si ben lontana dall'essere uniforme, ma questo non \`e importante dal momento che nessun distinguitore che viaggia in tempo polinomiale pu\`o 
accorgersene.


Nella pratica lo scopo di $G$ \`e prendere in input un $seed$ casuale, e da quello generare una variabile pseudocasuale molto pi\`u lunga. Si intuisce da questo la grandissima
importanza che hanno i generatori pseudocasuali in crittografia. Per esempio il seed potrebbe corrispondere alla chiave di un cifrario, mentre l'output di $G$ di lunghezza $k$ potrebbe
essere il valore con cui viene fatto lo $XOR$ del messaggio (anch'esso di lunghezza $k$); otteniamo cos\`i una versione del one-time pad basato su una chiave pi\`u corta del messaggio.
Siccome una stringa pseudocasuale appare, ad un distinguitore efficiente $D$, come una stringa casuale, $D$ non ottiene un vantaggio sensibile nel passaggio dal vero one-time pad
al one-time pad che usa una chiave pseudocasuale. In generale i generatori pseudocasuali sono molto utili in crittografia per creare schemi crittografici simmetrici.

\section{Dimostrazioni Basate su Games}
In questo paragrafo si cercher\`a di spiegare cosa siano nell'ambito della crittografia i \emph{games}\footnote{Che intenderemo letteralmente come "giochi".} e come siano strutturate la
maggior parte delle dimostrazioni che utilizzano sequenze di games.\\Si possono trovare approfondimenti riguardo a questi concetti nel lavoro di Shoup \cite{shoup}.
Quella basata sul concetto di game \`e una tecnica\footnote{Game hopping technique.} molto utilizzata per provare la sicurezza di primitive crittografiche o di protocolli crittografici.
Questi games sono giocati da un' ipotetica entit\`a maligna, l'attaccante, e da un'ipotetica parte benigna di solito chiamato sfidante\footnote{Perch\`e \emph{sfida} l'attaccante a 
vincere questo gioco.}. 
\`E difficile dare una definizione formale di game; infatti il concetto di game cambia, sebbene in maniera non sensibile, da situazione a situazione, da ambiente ad ambiente e 
da dimostrazione a dimostrazione (sia che queste siano fatte manualmente sia che queste siano automatiche e quindi dipendenti dal framework in cui vengono costruite).
Intuitivamente per\`o, i game possono essere immaginati come un insieme di azioni, modellate in una particolare algebra di processi, 
che servono a specificare il comportamento dei partecipanti al gioco, ovvero le entit\`a che partecipano come \emph{principals} al protocollo crittografico.\\
Il lettore trover\`a utile pensarli, almeno nell'ambito di questa tesi, come insiemi di processi che, fra le altre cose, forniscono un'interfaccia all'attaccante attraverso degli 
\emph{oracoli} che possono resitituire dei valori all'attaccante. Questi oracoli, prima di ritornare il valore, possono effettuare calcoli, dichiarare ed utilizzare variabili che non saranno
visibili all'esterno.\\Si deve pensare agli oracoli come delle scatole nere inaccessibili dall'esterno. Questi oracoli una volta interrogati forniscono una risposta,
e questo \`e il massimo livello di interazione che dall'esterno si pu\`o avere con queste entit\`a.\\ \\
Il primo passo che le dimostrazioni di sicurezza basate su sequenze di game fanno, \`e quello di modellare il protocollo crittografico reale in un game iniziale $G_0$.
In $G_0$ esiste la probabilit\`a non nulla che un evento \emph{negativo} possa accadere (immaginiamolo come una sorta di vittoria da parte dell'attaccante).
Ora, in generale, si procede effettuando delle modifiche al game $G_i$ ottenendo un game $G_{i+1}$ 
tale che $G_i$ e $G_{i+1}$ siano computazionalmente indistinguibili. Le modifiche che si effettuano fra un game e un altro devono introdurre delle differenze computazionalmente irrilevanti.
Queste modifiche possono essere viste come regole di riscrittura delle distribuzioni di probabilit\`a delle variabili in gioco nei game.
Se per esempio in un game $G_i$ un processo ha a che fare con un variabile casuale, e nel game $G_{i+1}$ questa viene sostituita con una variabile che invece \`e pseudocasuale, non vengono introdotte
modifiche computazionalmente rilevanti e quindi il passaggio \`e lecito, visto che i due game non sono distinguibili se non con probabilit\`a trascurabile.
Alla fine si arriva ad un game $G_f$ in cui \emph{l'evento} non pu\`o accadere. Se, quindi, nel game finale l'attaccante non ha possibilit\`a di vincere e il game finale
\`e computazionalmente indistinguibile dal penultimo, questo lo \`e dal terzultimo e cos\`i via fino a $G_0$, allora
il game finale \`e computazionalmente indistinguibile dal primo\footnote{Ricordiamo infatti che la somma di due probabilit\`a trascurabili rimane trascurabile.}. 
Adesso, quindi, se nel game iniziale esiste la possibilit\`a che un evento avvenga, e nel game finale no,
si pu\`o dare un limite superiore alla probabilit\`a che l'evento avvenga nel game iniziale. Questo limite \`e la somma di tutte le probabilit\`a con cui un attaccante riesce a distinguere un game dal successivo all'interno della sequenza.

\`E importante dire che, anche nel modello formale si possono utilizzare le sequenze di game, la differenza \`e che due game successivi non sono computazionalmente indistinguibili 
ma sono perfettamente indistinguibili. In particolare quello che si vuole sottolineare \`e che: se in una sequenza di game $G_b$ e $G_a$ sono l'uno il successore dell'altro, 
allora i due game 
devono appartenere ad una stessa classe di equivalenza indotta dalla particolare relazione di equivalenza che il modello in cui si sta costruendo la catena di games sfrutta.
Nel modello formale questa relazione sar\`a l'indistinguibilit\`a perfetta (meglio nota come equivalenza osservazionale) mentre in quello computazionale sar\`a 
l'indistinguibilit\`a computazionale.
\chapter{CryptoVerif}
CryptoVerif \`e un \emph{dimostratore} automatico che lavora direttamente nel modello computazionale. \`E un tool molto recente e in continuo sviluppo (pi\`u informazioni).\\
CryptoVerif \`e stato scritto da Bruno Blanchet\footnote{Ricercatore al LIENS (Computer Science Laboratory of Ecole Normale Supérieure)} in Ocaml. 
Si possono trovare pi\`u informazioni nella home page di Blanchet\footnote{\url{http://www.di.ens.fr/~blanchet/index-eng.html}}.
Questo tool \`e utilizzato per dimostrare propriet\`a di segretezza e autenticazione. Queste prove si basano sulla tecnica delle sequenze di game.
Il tool \`e liberamente scaricabile\footnote{\url{http://www.cryptoverif.ens.fr/cryptoverif.html}} sotto la licenza CeCill\footnote{http://www.cecill.info/licences/}.
CryptVerif \`e stato gi\`a utilizzato per dimostrare la correttezza di alcuni protocolli crittografici, come per esempio: FDH \cite{BlanchetPointchevalCrypto06}, 
Kerberos \cite{BlanchetJaggardScedrovTsayAsiaCCS08}.
\newpage
\section{La sintassi}
La sintassi di un sott'insieme del calcolo di processi che CryptoVerif implementa \`e descritta nelal figura 1.\\
Verr\`a descritta solo la parte utile per capire gli esempi riportati.

{\setlength\tabcolsep{4pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
   M, P &\Coloneqq &$i$\\
  &| & $x[$\;M_1, \dots M_m$ \;]$ \\
  &| &e_1 \; op_b \; e_2\\
  &| &op_m \; e\\
  &| &(e)\\
  &| &f(es)\\
  es &\Coloneqq &e\\
  &| &e, \; es\\
  S &\Coloneqq &x := e;\\
  &| &skip;\\
  &| &read \; x;\\
  &| &write \; e;\\
  &| &return \; e;\\
  &| &if(e) \; S_1 \; else \; S_2\\
  &| &while(e) \; S\\
  &| &\{Ds \; Ss\}\\
  &| &\{Ss\}\\
  Ss &\Coloneqq &S\\
  &| &S \; Ss\\
  Ds &\Coloneqq &T \; x;\\
  &| &T \; x; Ds\\
  Fs &\Coloneqq &T \; f(Ds)\{Ss\}\\
  &| &T \; f(Ds)\{Ss\} \; Fs\\
  T &\Coloneqq &int\\
  &| &float\\
  P &\Coloneqq &program \; Ds \; Fs \; Ss \; end
\end{tabular}}

Come possiamo vedere questo calcolo distingue due tipi di processi:
\begin{itemize}
 \item Definizioni di Oracoli.
 \item Corpi di Oracoli.
\end{itemize}
La definizione di un oracolo permette di assegnare a questo un nome e di specificare il tipo e il nome dei parametri in input. Il corpo di un oracolo pu\`o effettuare
delle operazioni e infine pu\`o ritornare un valore. Fra le operazioni che pu\`o effettuare ci sono:

\begin{enumerate}
 \item Assegnamento di un valore ad una variabile
 \item Assegnamento di un valore scelto casualmente da un dominio ad una variabile
 \item Assegnamento condizionale di una chiamata di oracolo
 \item array lookup
 \item esecuzione di eventi
\end{enumerate}

La semantica della terza voce \`e la seguente: se l'oracolo O ritorna un valore con la seguente istruzione : \return{x} allora questo valore \`e assegnato a $x_1$ altrimenti viene
eseguito $P$.
il processo "if defined" \`e zucchero sintattico per "find....".
Quello che segue \`e un piccolo esempio di dichiarazione di oracolo:




La sintassi di un array lookup \`e \emph{find ...} dove \~i denota una tupla.  Questo processo prova a trovare $j \in [1, m]$ tale che eistono i valori uj1...ujm tali che
Mj1, Mjm sono definiti e Mj \\`e vero. In caso di successo esegue Pj altrimenti, se falliscono tutti i tentativi, esegue P.
In maniera pi\`u formale possiamo dire che, valuta la condizione defined() per ogni j e ogni valore valore di uj... .Se nessuna di queste condizioni \`e vera esegue P, altrimenti
sceglie con probabilit\`a uniforme un j e esegue Pj.

































\section{Un Esempio: FDH}
\emph{Full Domain Hash} \`e uno schema di firma che segue il paradigma \emph{hash-and-sign}\footnote{Questo paradigma vuole che: dato un messaggio $m$ se ne ritorni 
la firma di $hash(m)$ e non la firma di $m$, dove la funzione hash pu\`o essere istanziata con qualsiasi funzione hash collision resistant. 
Si ottiene cos\`i una firma di lunghezza fissa e non dipendente dalla lunghezza del messaggio}. 
Quella che a breve seguir\`a \`e una sequenza di game costruita dal CryptoVerif che d\`a un limite superiore alla probabilit\`a che un attaccante riesca a forgiare una firma valida
per un messaggio.\newpage
L'input che si fornisce al CryptoVerif \`e costituito, fondamentalmente, da due parti: 
\begin{itemize}
 \item Un game iniziale $G_0$, in cui si modella la sicurezza dello schema.
 \item Alcune equivalenze necessarie a CryptoVerif per effettuare le modifiche ai game. 
\end{itemize}
La descrizione dello schema di firma \emph{FDH} viene data al CryptoVerif attraverso il seguente game:\\ \\
\begin{tabular}{lcr}
\hline
$G_0 \equiv$ \foreach{iH}{qH} OH(x: bitstring):= \return{hash(x)}\pipe Ogen():=\setR{r}{seed}\set{pk}{pkgen(r)}\set{sk}{skgen(r)}\return{pk}\\
	(\foreach{iS}{qS} OS(m: bitstring):= \return{invf(sk, hash(m))})\pipe
	OT(m': bitstring, s:D):=\\ \ifthen{f(pk, s)=hash(m')}{\find{u}{qS}{m[u]} {$m^{'}=m[u]$} {\myend} {\event} forge}
	\\
\hline 
\end{tabular}\\ \\
Procediamo adesso con una breve spiegazione di questo game.
Possiamo vedere come in questo game si forniscano $qH$ copie dell' oracolo $OH$ i quali ritornano l'hash della stringa che gli si fornisce in input ovvero $x$.
Abbiamo poi il processo $Ogen()$ che ritorna al contesto una chiave pubblica dopo aver creato, partendo da un seme casuale, una coppia costituita da una chiave privata e una chiave pubblica.
Abbiamo poi $qS$ copie dell'oracolo $OS$ che si occupano di fornire una firma del messaggio che gli viene dato in input. Infine abbiamo un singolo oracolo $OT$ che si occupa di verificare
se la firma $s$ \`e valida per il messaggio $m^{'}$. In particolare se $hash(m^{'}) \neq f(pk, s)$ allora la firma non \`e valida per il messaggio. Se invece $hash(m^{'}) = f(pk, s)$
l'oracolo si occupa di verificare se, per il messaggio $m^{'}$, \`e stata mai rilasciata una firma dall'oracolo $OS$, in caso affermativo il processo termina, altrimenti significa che 
il contesto, ovvero l'attaccante, \`e stato in grado di forgiare una firma valida per il messaggio, e quindi \`e avvenuto l'evento \emph{forge}.
Notiamo come l'attaccante non sia modellato esplicitamente, infatti non possiamo fare nessuna assunzione sul comprtamento di questo.
Possiamo immaginare un attaccante come un altro processo non meglio specificato messo in parallelo con questo game. In gergo l'attaccante viene anche detto anche \emph{contesto}.
Per poter trasformare un game in un altro CryptoVerif ha bisogno di alcune equivalenze da poter utilizzare.
Le definizioni in CryptoVerif vengono fornite attraverso delle equivalenze che possono essere viste come regole di riscrittura delle distribuzioni di probabilit\`a delle variabili in
gioco.
Queste regole di riscrittura di un generico elemento \emph{L} in un generico elemento \emph{R} possono valere incondizionatamente, 
oppure possono valere a meno di una certa probabilit\`a.
Nel secondo caso la riscrittura di un termine L nell'equivalente R comporta l'introduzione di una differenza non nulla fra i due game.

Prima di descrivere il secondo input di CryptoVerif \`e necessario fare una piccola digressione riguardo al concetto di funzione \emph{one-way}.
Intuitivamente una funzione $f$ \`e one-way se non pu\`o essere invertita facilmente. Cio\`e se dato $y=f(x)$ \`e arduo riuscire a trovare un $x'$ tale che $f(x')=y$. 
Si noti come non sia necessario, per invertire la funzione, trovare $x$ ma \`e sufficiente trovare un $x'$ qualsiasi tale che $f(x')=y$.
\\Possiamo ora dare la seguente:
\begin{definizione}{Funzione One-Way.}
$f: \{0,1\}^*\rightarrow \{0,1\}^*$ \`e one-way se e solo se $\forall x \in  \{0,1\}^* \hbox{,} \forall A \in PPT$:  $\lvert Pr[A(f(x)) \in f^{-1}(f(x))]\rvert$ \`e una funzione 
trascurabile.
\end{definizione}

\`E importante notare come la definizione valga per ogni $x$ del dominio; con questo si vuole sottolineare che invertire $f$ deve essere \emph{sempre} difficile e non per particolari $x$.
\`E importante affermare ci\`o perch\`e tutta la crittografia moderna \`e fondata sull'ipotesi che esistano le funzioni one-way.
Si parla di ipotesi perch\`e, sebbene la maggior parte degli informatici ne sia convinta, non \`e stato ancora dimostrata l'esistenza di funzioni di questo genere\footnote{Questo non toglie
che esistono funzioni che si avvicinano all'idea che abbiamo di funzioni one-way, per esempio SHA1, o MD5.}.
La dimostrazione dell'esistenza di funzioni one-way comporterebbe, tra l'altro, anche la risoluzione della famosa questione riguardo agli insiemi
$P$ e $NP$\footnote{$P$ \`e l'insieme dei problemi risolvibili nel caso pessimo in un numero di passi polinomiale nell'input. $NP$ invece, \`e l'insieme dei problemi per cui dato un certo valore, 
si pu\`o verificare in tempo polinomiale se questo \`e o meno soluzione del problema (ovvero \`e l'insieme dei problemi con certificazione polinomiale.). 
Non \`e ancora noto se questi insiemi siano o meno lo stesso insieme.}.
Il fatto che però qualcuno un giorno possa dimostrare che $P \neq NP$ non dimostrerebbe affatto l'esistenza delle funzioni one-way. 
Infatti una funzione one-way deve, come prima sottolineato, essere non invertibile in modo efficiente, sempre e non solo nel \emph{caso pessimo}. 
\newpage
Siamo ora pronti per vedere come il concetto di funzione one-way viene modellato in CryptoVerif.


Si tratta di dare una definzione di one-way per mezzo di un'equivalenza fra games. La definizione \`e la seguente:\\
\equiva \\
\foreach{ik}{nk} \setR{r}{seed} (Opk():= \return{r} )\pipe 
 \foreach{iF}{nF} \setR{x}{D} (Oy():= \return{f(pkgen(r), x)} \pipe
  \foreach{i1}{n1} Oeq(x': D):= \return{x'=x} \pipe 
    Ox():=\return{x} \\
\textbf{$\approx _{pow}$}\\
\foreach{ik}{nk} \setR{r}{seed} (Opk():= \return{r} )\pipe 
 \foreach{iF}{nF} \setR{x}{D} (Oy():= \return{f'(pkgen'(r), x)} \pipe
  \foreach{i1}{n1} Oeq(x': D):= \ifthen{\textbf{defined}(k)}{\return{x'=x}} \\ \textbf{else}  \return{false} \pipe 
    Ox():=\set{k}{mark}\return{x} \\


Questa equivalenza fra game cattura e definisce il concetto di funzione one-way. La funzione $f$, infatti, \`e one-way se e solo se vale l'equivalenza $nNXXX$, 
e quindi il game a sinistra e quello a destra del simbolo \textbf{$\approx _{pow}$} sono indistinguibili.
Supponiamo, infatti, che la funzione $f$ non sia one-way, esister\`a dunque un avversario efficiente $A$ 
che pu\`o invertire $f$. $A$ sar\`a dunque in grado di distinguere i due membri dell'equivalenza $L \approx_{pow} R$.
Potendo invertire $f$, $A$ sar\`a in grado di osservare comportamenti diversi fra i game a seconda che $A$ chiami Oeq() in $L$ o in $R$.
Supponiamo, dunque, che $A$ chiami Oy() ottenendo l'immagine di un valore mediante $f$, sia questa $y$; poich\`e $f$ non \`e one-way, 
$A$ inverte la funzione ottenendo un $x^{'}$ tale che $f(x^{'})= y$.
Adesso $A$ non deve far altro che richiamare Oeq passando a questo come argomento $x^{'}$. Se l'Oeq richiamato appartiene al primo membro dell'equivalenza, 
allora Oeq()  ritorner\`a sempre true, mentre se appartiene al secondo ritorner\`a sempre false. In questo modo $A$ osserva dei comportamenti diversi fra i due game, 
e quindi pu\`o distinguerli. Supponiamo invece che $f$ sia effettivamente one-way. Allora non esister\`a nessun attaccante efficiente che riesca ad invertire $f$.
L'unico modo che ha quindi un attaccante $A$ per invertire la funzione, \`e chiamare Ox() e ottenere cos\`i una preimmagine valida. 
Se però l'attaccante chiama Ox() allora $L$ e $R$ sono effettivamente indistinguibili (a meno di probabilit\`a trascurabili).
Notiamo infatti nella definizione dell'equivalenza che Ox() \`e definito in maniera diversa in $L$ ed $R$.
In $L$, Ox() si occupa semplicemente di ritornare il valore del dominio $x$, tale che $f(x)=y$. In $R$ invece Ox() prima di ritornare $x$ imposta al valore $mark$ la variabile $k$.
Ora, l'Oeq si comporter\`a in maniera diversa a seconda che appartenga ad $L$ o ad $R$.
Se infatti l'Oeq() richiamato appartiene ad $L$ allora Oeq() si proccuper\`a semplicemente di ritornare il valore booleano dell'espressione $x^{'}=x$.
Se invece, l'Oeq() richiamato appartiene ad $L$ allora Oeq() si comporter\`a in maniera differente a seconda che la variabile $k$ abbia o meno un valore 
(ovvero sia stata o meno definita da una precedente chiamata a Ox). Se quindi $k$ \`e definito Oeq si comporter\`a esattamente come si sarebbe comportato l'Oeq di $L$.
Se invece k non \`e stato definito allora siginifica che l'attaccante non ha richiamato Ox, quindi \`e lecito supporre che non sia riuscito ad invertire $f$ e quindi Oeq ritorna false\footnote{
\`E importante notare che l'attaccante ha comunque la possibilit\`a di indovinare $x$ anche senza richiamare Ox ma questa \`e una probabilit\`a trascurabile. Di questa probabilit\`a viene
comunque tenuto conto nell'equivalenza. L'equivalenza infatti, vale a meno di una certa probabilit\`a $pow$ (trascurabile in questo caso).}.
In questo modo i due game sono effettivamente indistinguibili, perch\`e non presentano differrenze di comportamento che $A$ possa notare, e quindi ai suoi occhi sono indistinguibili.
Quindi $L$ e $R$ sono \`e indistinguibile \emph{se e solo se} $f$ \`e one-way; quindi la precedente equivalenza \`e una definizione ben posta di funzione one-way.
Un'ulteriore definizione viene fornita al CryptoVerif, quella di funzione hash. Questa definizione viene fornita al tool attraverso il seguente codice:

 \equiva \\ 
  \foreach{iH}{nH} OH(x:hashinput) := \return{hash(x)}\\
    \textbf{$\approx _{pow}$}\\  
     \foreach{iH}{nH} OH(x:hashinput) :=
   \find{u}{nH}{x[u],r[u]}{x= x[u]}{return(r[u])}{\setR{r}{hashoutput}; \return{r}.}
 
La funzione hash \`e intesa implementata nel modello dell'oracolo random: se la funzione non \`e mai stata richiamata su un particolare valore $x_0$ allora viene ritornato un valore casuale, 
altrimenti viene ritornato lo stesso valore che era stato ritornato precedentemente. Questo viene fatto salvando il valore ritornato per un particolare input in un array e poi,
al momento della chiamata, si effettua un look up nell'array.
Infine abbiamo una semplice teoria equazionale per descrivere alcune propriet\`a delle funzioni in gioco.\newpage
Per esempio:
\begin{verbatim}
 forall r:seed, x:D, x':D; (x' = invf(skgen(r),x)) = (f(pkgen(r),x') = x).
 forall r:seed, x:D; f(pkgen(r), invf(skgen(r), x)) = x.
 forall r:seed, x:D; invf(skgen(r), f(pkgen(r), x)) = x.
\end{verbatim}
Le precedenti regole servono a definire $invf$ come funzione inversa di $f$ e viceversa. Mentre le seguenti:
\begin{verbatim}
forall k:skey, x:D, x':D; (invf(k,x) = invf(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f(k,x) = f(k,x')) = (x = x').
forall k:pkey, x:D, x':D; (f'(k,x) = f'(k,x')) = (x = x).
\end{verbatim}\\
modellano l'iniettivit\`a delle funzioni $invf$, $f'$, $f$\footnote{Non serve ai fini della dimostrazione modellare l'iniettivit\`a della funzione $invf'$.}.
Quella che segue \`e una spiegazione delle parti pi\`u importanti dell'output di CryptoVerif quanto questo viene eseguito sull'input prima descritto.
Nell'appendice XX si pu\`o trovare l'input e l'output completo del CryptoVerif.
Nel game $G_0$ viene per prima cosa sostituita ogni chiamata ad hash con la relativa definizione.
Dopo queste modifiche CryptoVerif ottiene il seguente game:
\begin{verbatim}
 (
  foreach iH 13 ≤ qH do
  OH(x : bitstring) :=
  x23 : bitstring ← x ;
  find suchthat defined(x19 , r18 ) ∧ (x23 = x19 ) then
    return(r18 )
  ⊕ @i 29 ≤ qS suchthat defined(x21 [@i 29 ], r20 [@i 29 ]) ∧ 
    (x23 = x21 [@i 29 ]) then
    return(r20 [@i 29 ])
  ⊕ @i 28 ≤ qH suchthat defined(x23 [@i 28 ], r22 [@i 28 ]) ∧ 
    (x23 = x23 [@i 28 ]) then
    return(r22 [@i 28 ])
  else
         R
    r22 ← D;
    return(r22 )
|
  Ogen() :=
    R
  r ← seed ;
  pk : pkey ← pkgen(r );
  sk : skey ← skgen(r );
  return(pk );
  (
    foreach iS 14 ≤ qS do
    OS(m : bitstring) :=
    x21 : bitstring ← m;
    find suchthat defined(x19 , r18 ) ∧ (x21 = x19 ) then
       return(invf(sk , r18 ))
    ⊕ @i 27 ≤ qS suchthat defined(x21 [@i 27 ], r20 [@i 27 ]) ∧ 
      (x21 = x21 [@i 27 ]) then
       return(invf(sk , r20 [@i 27 ]))
    ⊕ @i 26 ≤ qH suchthat defined(x23 [@i 26 ], r22 [@i 26 ]) ∧ 
      (x21 = x23 [@i 26 ]) then
       return(invf(sk , r22 [@i 26 ]))
    else
            R
       r20 ← D;
       return(invf(sk , r20 ))
  |
    OT (m : bitstring, s : D) :=
    x19 : bitstring ← m ;
    find suchthat defined(x19 , r18 ) ∧ (x19 = x19 ) then
1
       if (f(pk , s) = r18 ) then
       find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
          end
       else
          event forge
    ⊕ @i 25 ≤ qS suchthat defined(x21 [@i 25 ], r20 [@i 25 ]) ∧ 
	(x19 = x21 [@i 25 ]) then
2
3      if (f(pk , s) = r20 [@i 25 ]) then
       find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
4
          end
       else
          event forge
    ⊕ @i 24 ≤ qH suchthat defined(x23 [@i 24 ], r22 [@i 24 ]) ∧ 
	(x19 = x23 [@i 24 ]) then
       if (f(pk , s) = r22 [@i 24 ]) then
       find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
          end
       else
          event forge
    else
            R
       r18 ← D;
       if (f(pk , s) = r18 ) then
       find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
          end
       else
          event forge
  )
)
\end{verbatim}
Nel game precedente il simbolo \begin{verbatim}⊕\end{verbatim}
sta a significare \foreach{j}{Q} dove $Q$ \`e il limite superiore dell'array e $j$ la variabile
usata per scorrerlo. 
Questo game adesso viene modificato nel modo seguente: poich\`e alla linea $1$ $r_{18}$ non \`e definita il relativo test fallisce sempre quindi
pu\`e essere eliminato.

\begin{verbatim}
 (
  foreach iH 13 ≤ qH do
  OH(x : bitstring) :=
  x23 : bitstring ← cst bitstring;
  find suchthat defined(m , x19 , r18 ) ∧ (x = m ) then
    return(f(pkgen(r ), r18 ))
  ⊕ @i 29 ≤ qS suchthat defined(m[@i 29 ], x21 [@i 29 ], r20 [@i 29 ]) ∧ 
    (x = m[@i 29 ]) then
	return(f(pkgen(r ), r20 [@i 29 ]))
  ⊕ @i 28 ≤ qH suchthat defined(x [@i 28 ], x23 [@i 28 ], r22 [@i 28 ]) ∧ 
    (x = x [@i 28 ]) then
    return(f(pkgen(r ), r22 [@i 28 ]))
  else
         R
    r22 ← D;
    return(f(pkgen(r ), r22 ))
|
  Ogen() :=
    R
  r ← seed ;
  pk : pkey ← pkgen(r );
  return(pk );
  (
    foreach iS 14 ≤ qS do
    OS(m : bitstring) :=
    x21 : bitstring ← cst bitstring;
    find suchthat defined(m , x19 , r18 ) ∧ (m = m ) then
       return(r18 )
    ⊕ @i 27 ≤ qS suchthat defined(m[@i 27 ], x21 [@i 27 ], r20 [@i 27 ]) ∧ 
    (m = m[@i 27 ]) then
       return(r20 [@i 27 ])
    ⊕ @i 26 ≤ qH suchthat defined(x [@i 26 ], x23 [@i 26 ], r22 [@i 26 ]) ∧ 
    (m = x [@i 26 ]) then
       return(r22 [@i 26 ])
    else
            R
       r20 ← D;
       return(r20 )
  |
    OT (m : bitstring, s : D) :=
    x19 : bitstring ← cst bitstring;
    find @i 25 ≤ qS suchthat defined(m[@i 25 ], x21 [@i 25 ], r20 [@i 25 ]) ∧ 
     (m = m[@i 25 ]) then
       end
    ⊕ @i 24 ≤ qH suchthat defined(x [@i 24 ], x23 [@i 24 ], r22 [@i 24 ]) ∧ 
      (m = x [@i 24 ]) then
       if (f(pk , s) = f(pkgen(r ), r22 [@i 24 ])) then
       find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
          end
      else
         event forge
    else
           R
      r18 ← D;
      if (f(pk , s) = f(pkgen(r ), r18 )) then
      find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
         end
      else
         event forge
  )
)

\end{verbatim}

\begin{verbatim}
 (
  foreach iH 13 ≤ qH do
  OH(x : bitstring) :=
  find suchthat defined(m , r , r18 ) ∧ (x = m ) then
    return(f (pkgen (r ), r18 ))
  ⊕ @i 29 ≤ qS suchthat defined(m[@i 29 ], r , r20 [@i 29 ]) ∧ (x = m[@i 29 ]) then
    return(f (pkgen (r ), r20 [@i 29 ]))
  ⊕ @i 28 ≤ qH suchthat defined(x [@i 28 ], r22 [@i 28 ]) ∧ (x = x [@i 28 ]) then
    return(f (pkgen (r ), r22 [@i 28 ]))
  else
         R
    r22 ← D;
    return(f (pkgen (r ), r22 ))
|
  Ogen() :=
    R
  r ← seed ;
  pk : pkey ← pkgen (r );
  return(pk );
  (
    foreach iS 14 ≤ qS do
1   OS(m : bitstring) :=
    find suchthat defined(m , r18 ) ∧ (m = m ) then
2
       k47 : bitstring ← mark;
3
       return(r18 )
     ⊕ @i 27 ≤ qS suchthat defined(m[@i 27 ], r20 [@i 27 ]) ∧ (m = m[@i 27 ]) then
       k48 : bitstring ← mark;
       return(r20 [@i 27 ])
     ⊕ @i 26 ≤ qH suchthat defined(x [@i 26 ], r22 [@i 26 ]) ∧ (m = x [@i 26 ]) then
4
       k50 : bitstring ← mark;
5
       return(r22 [@i 26 ])
     else
            R
       r20 ← D;
       k45 : bitstring ← mark;
       return(r20 )
   |
     OT (m : bitstring, s : D) :=
     find @i 25 ≤ qS suchthat defined(r20 [@i 25 ], m[@i 25 ]) ∧ (m = m[@i 25 ]) then
       end
     ⊕ @i 24 ≤ qH suchthat defined(x [@i 24 ], r22 [@i 24 ]) ∧ (m = x [@i 24 ]) then
6
       find @i 56 ≤ qS suchthat defined(k50 [@i 56 ]) ∧ (@i 24 = @i 26 [@i 56 ]) then
7
          if (s = r22 [@i 24 ]) then
          find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
8
             end
          else
             event forge
       else
9         if false then
          find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
             end
          else
             event forge
     else
            R
       r18 ← D;
       find @i 53 ≤ qS suchthat defined(k47 [@i 53 ]) then
10
          if (s = r18 ) then
          find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
11
             end
          else
             event forge
       else
12        if false then
          find u ≤ qS suchthat defined(m[u]) ∧ (m = m[u]) then
             end
          else
             event forge
   )
)

\end{verbatim}
\chapter{Risultati Raggiunti}
\chapter{Conclusioni}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\bibliographystyle{alpha}	
\bibliography{myrefs}		
\end{document}          
